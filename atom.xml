<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ned Lee&#39;s bolg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-16T14:56:29.038Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ned Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronized和lock的区别</title>
    <link href="http://yoursite.com/2020/05/16/synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/16/synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-16T14:54:12.000Z</published>
    <updated>2020-05-16T14:56:29.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="1-作用的位置不同"><a href="#1-作用的位置不同" class="headerlink" title="1.作用的位置不同"></a>1.作用的位置不同</h4><p>synchronized可以给方法，代码块加锁</p><p>lock只能给代码块加锁</p><h4 id="2-锁的获取锁和释放机制不同"><a href="#2-锁的获取锁和释放机制不同" class="headerlink" title="2.锁的获取锁和释放机制不同"></a>2.锁的获取锁和释放机制不同</h4><p>synchronized无需手动获取锁和释放锁，发生异常会自动解锁，不会出现死锁。</p><p>lock需要自己加锁和释放锁，如lock()和unlock()，如果忘记使用unlock()，则会出现死锁，</p><p>所以，一般我们会在finally里面使用unlock().</p><h4 id="3-lock锁的特殊要求"><a href="#3-lock锁的特殊要求" class="headerlink" title="3.lock锁的特殊要求"></a>3.lock锁的特殊要求</h4><p>//明确采用人工的方式来上锁</p><p>lock.lock();</p><p>//明确采用手工的方式来释放锁</p><p>lock.unlock();</p><h4 id="4-关于synchronized"><a href="#4-关于synchronized" class="headerlink" title="4.关于synchronized"></a>4.关于synchronized</h4><p>synchronized修饰成员方法时，默认的锁对象，就是当前对象</p><p>synchronized修饰静态方法时，默认的锁对象，当前类的class对象，比如User.class</p><p>synchronized修饰代码块时，可以自己来设置锁对象，比如</p><p>synchronized(this){</p><p>//线程进入，就自动获取到锁</p><p>//线程执行结束，自动释放锁</p><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库的三大范式</title>
    <link href="http://yoursite.com/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</id>
    <published>2020-05-16T11:55:15.000Z</published>
    <updated>2020-05-16T11:56:17.537Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1，数据库的三大范式"><a href="#1，数据库的三大范式" class="headerlink" title="1，数据库的三大范式"></a><strong>1，数据库的三大范式</strong></h2><blockquote><p>第一范式：列不可分<br>第二范式：要有主键<br>第三范式：不可存在传递依赖<br>比如商品表里面关联商品类别表，那么只需要一个关联字段product_type_id即可，其他字段信息可以通过表关联查询即可得到<br><strong>如果商品表还存在一个商品类别名称字段，如product_type_name，那就属于存在传递依赖的情况，第三范式主要是从空间的角度来考虑，避免产生冗余信息，浪费磁盘空间</strong></p></blockquote><h2 id="2，反范式设计：-第三范式"><a href="#2，反范式设计：-第三范式" class="headerlink" title="2，反范式设计：(第三范式)"></a><strong>2，反范式设计：(第三范式)</strong></h2><blockquote><p>为什么会有反范式设计？<br>原因一：提高查询效率（读多写少）<br>比如上述的描述中，显示商品信息时，经常需要伴随商品类别信息的展示，<br>所以这个时候，为了提高查询效率，可以通过冗余一个商品名称字段，这个可以将原先的表关联查询转换为单表查询</p></blockquote><blockquote><p>原因二：保存历史快照信息<br>比如订单表，里面需要包含收货人的各项信息，如姓名，电话，地址等等，这些都属于历史快照，需要冗余保存起来，<br>不能通过保存用户地址ID去关联查询，因为用户的收货人信息可能会在后期发生变更</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>对ThreadLocal的理解</title>
    <link href="http://yoursite.com/2020/05/16/%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/16/%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-05-16T02:17:08.000Z</published>
    <updated>2020-05-18T06:59:13.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>作用：</p><p>为每一个线程创建一个副本</p><p>主要实现了在线程的上下文传递对象</p><h4 id="第一个问题：证明ThreadLocal为每个线程创建一个变量副本"><a href="#第一个问题：证明ThreadLocal为每个线程创建一个变量副本" class="headerlink" title="第一个问题：证明ThreadLocal为每个线程创建一个变量副本"></a>第一个问题：证明ThreadLocal为每个线程创建一个变量副本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Long&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;开启多个线程来执行任务</span><br><span class="line">        Task task &#x3D; new Task();</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Long result &#x3D; threadLocal.get();</span><br><span class="line">            if(result &#x3D;&#x3D; null)&#123;</span><br><span class="line">                threadLocal.set(System.currentTimeMillis());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;-&gt;&quot;+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是不同的</p><h4 id="问题二：为什么可以给每个线程保存一个不同的副本"><a href="#问题二：为什么可以给每个线程保存一个不同的副本" class="headerlink" title="问题二：为什么可以给每个线程保存一个不同的副本"></a>问题二：为什么可以给每个线程保存一个不同的副本</h4><p>那我们来分析源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Long result = threadLocal.get();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2，获取到当前线程对应的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.以threadLocal为key，获取到entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//4.获取对应entry的value，就是我们存放到里面的变量的副本</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们需要结合set方法的源码分析，才可以更好理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取到当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2.获取当前线程对应的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//3.往map存放一个键值对</span></span><br><span class="line">            <span class="comment">//this ThreadLocal</span></span><br><span class="line">            <span class="comment">//value 保存的副本</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，我们得到结论：</p><p>每个线程都会有对应的map，map来保存键值对。</p><h4 id="问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？"><a href="#问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？" class="headerlink" title="问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？"></a>问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？</h4><p>比如：hibernate管理session，mybatis管理sqlsession，其内部都是采用ThreadLocal来实现的。</p><p>前提知识：不管是什么框架，最本质的操作都是基于JDBC，当我们需要跟数据库打交道的时候，都需要有一个connection。</p><p>那么，当我们需要在业务层实现事务控制时，该如何达到这个效果？</p><p>我们构建下代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略接口的声明</span><br><span class="line">    private UserDao userDao &#x3D; new UserDao();</span><br><span class="line">    private LogDao logDao &#x3D; new LogDao();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;事务的边界放在业务层</span><br><span class="line">    &#x2F;&#x2F;JDBC的封装，connection</span><br><span class="line">    public void add()&#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">        logDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;UserDao add。。。&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建connection对象</span><br><span class="line">        &#x2F;&#x2F;connection.commit();</span><br><span class="line">        &#x2F;&#x2F;connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LogDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;LogDao add。。。&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建connection对象</span><br><span class="line">        &#x2F;&#x2F;connection.commit();</span><br><span class="line">        &#x2F;&#x2F;connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码按上面的方式来管理connection，我们还可以保证service的事务控制吗？</p><p>这是不行的，假设第一个dao操作成功了，那么它就提交事务了，而第二个dao操作失败了，它回滚了事务，但不会影响到第一个dao的事务，因为上面这么写是两个独立的事务</p><p>那么怎么解决。</p><p>上面的根源就是两个dao操作的是不同的connection</p><p>所以，我们保证是同个connection即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;事务的边界放在业务层</span><br><span class="line">&#x2F;&#x2F;JDBC的封装，connection</span><br><span class="line">public void add()&#123;</span><br><span class="line">    Connection connection &#x3D; new Connection();</span><br><span class="line">    userDao.add(connection);</span><br><span class="line">    logDao.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方式代码不够优雅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Connection&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line">        Connection connection &#x3D; threadLocal.get();</span><br><span class="line">        if(connection &#x3D;&#x3D; null)&#123;</span><br><span class="line">            connection &#x3D; new Connection();</span><br><span class="line">            threadLocal.set(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;UserDao add。。。&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建connection对象</span><br><span class="line">        &#x2F;&#x2F;connection.commit();</span><br><span class="line">        &#x2F;&#x2F;connection.rollback();</span><br><span class="line">        Connection connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line">        System.out.println(&quot;UserDao-&gt;&quot;+connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们可以保证两个dao操作的是同一个connection</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。 有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Sleep和wait的区别</title>
    <link href="http://yoursite.com/2020/05/15/Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/15/Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-15T12:49:02.000Z</published>
    <updated>2020-05-15T13:14:41.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="Sleep和wait的区别"><a href="#Sleep和wait的区别" class="headerlink" title="Sleep和wait的区别"></a>Sleep和wait的区别</h4><h5 id="1-所属的类不同"><a href="#1-所属的类不同" class="headerlink" title="1.所属的类不同"></a>1.所属的类不同</h5><p>sleep方法是定义在Thread上的</p><p>wait方法是定义在object上的</p><h5 id="2-对于锁资源的处理方式不同"><a href="#2-对于锁资源的处理方式不同" class="headerlink" title="2.对于锁资源的处理方式不同"></a>2.对于锁资源的处理方式不同</h5><p>sleep不会释放锁，也就是说，该资源还是在当前方法上，其他线程无法访问其资源</p><p>wait会释放锁，调用wait后，其他线程可访问先前被锁住的资源</p><h5 id="3-使用范围不同"><a href="#3-使用范围不同" class="headerlink" title="3.使用范围不同"></a>3.使用范围不同</h5><p>sleep可以使用在任何代码块</p><p>wait必须在同步方法或同步代码块执行</p><h5 id="4-与wait配套使用的方法"><a href="#4-与wait配套使用的方法" class="headerlink" title="4.与wait配套使用的方法"></a>4.与wait配套使用的方法</h5><ul><li>void notify()</li></ul><p>作用：唤醒在此对象监视器上等待的单个线程</p><ul><li>void notifyall()</li></ul><p>作用：唤醒在此对象监视器上等待的所有线程</p><ul><li>void wait() </li></ul><p>作用：导致当前线程等待，直到其他线程调用此对象的notify()方法或notifyall()方法</p><h5 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h5><p>(1)当线程调用wait()或者join时，线程都会进入到waiting状态，当调用notify或notifyall时，或者join的线程执行结束后，会进入runnable状态</p><p>(2)当线程调用sleep(time)，或者wait(time)时，进入time waiting状态</p><h5 id="6-为什么wait要定义在object中，而不定义在thread中？"><a href="#6-为什么wait要定义在object中，而不定义在thread中？" class="headerlink" title="6.为什么wait要定义在object中，而不定义在thread中？"></a>6.为什么wait要定义在object中，而不定义在thread中？</h5><p>因为Java的锁是对象级别的，而不是线程级别的</p><h5 id="7-为什么wait必须卸载同步代码块中"><a href="#7-为什么wait必须卸载同步代码块中" class="headerlink" title="7.为什么wait必须卸载同步代码块中"></a>7.为什么wait必须卸载同步代码块中</h5><p>原因是避免CPU切换到其他线程，而其他线程又提前执行了notify方法，那样就达不到我们的预期（先wait再由其他线程来唤醒），所以需要一个同步锁来保护</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>解决hash冲突的方法</title>
    <link href="http://yoursite.com/2020/05/15/%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/15/%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-15T07:44:48.000Z</published>
    <updated>2020-05-15T08:02:59.938Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="1-什么是哈希冲突？"><a href="#1-什么是哈希冲突？" class="headerlink" title="1.什么是哈希冲突？"></a>1.什么是哈希冲突？</h4><p>理解哈希函数</p><p>关键字和它在表中存储位置之间存在一种函数关系。这个函数我们称为为哈希函数。</p><p>hash:散列、杂凑 </p><p>​        就是把任意长度的输入，通过散列算法，变成固定长度的输出，这种是一种压缩映射.</p><pre><code>那么在这种情况下，不同的输入可能会产生相同的散列值，即这种状况下他们对应的哈希数的值是相同的，因为值相同所以不可能由散列值确定唯一的输入值，这种情况就是哈希冲突</code></pre><p>​        键(key)经过hash函数得到的结果作为地址去存放当前的键值对(key-value)(hashmap的存值方式)，但是却发现该地址已经有值了，就会产生冲突。这个冲突就是hash冲突了。</p><p>​        换句话说就是：如果两个不同对象的hashCode相同，这种现象称为hash冲突。</p><h4 id="2-解决哈希冲突"><a href="#2-解决哈希冲突" class="headerlink" title="2. 解决哈希冲突"></a>2. 解决哈希冲突</h4><p>解决哈希冲突主要有以下几种方法：</p><p><strong>开放定址法</strong></p><p><strong>再哈希法</strong></p><p><strong>链地址法</strong></p><p><strong>建立公共溢出区</strong></p><h5 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="(1)开放定址法"></a>(1)开放定址法</h5><p>这种方法的意思是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。（ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。）</p><p>线性探测再散列</p><p>当发生冲突的时候，顺序的查看下一个单元</p><p>二次(平方)探测再散列</p><p>当发生冲突的时候，在表的左右进行跳跃式探测</p><h5 id="2-再hash法"><a href="#2-再hash法" class="headerlink" title="(2)再hash法"></a>(2)再hash法</h5><p>​        这种方式是同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。</p><p>​        这种方法不易产生聚集，但增加了计算时间。</p><h5 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="(3)链地址法"></a>(3)链地址法</h5><p>​        将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><p>​        hashmap就是用此方法解决冲突的。这是Java1.7之前解决hash冲突的主要办法，但是在Java1.8之后，就对该方法进行了升级，运用红黑树的算法解决插入值相同过多的问题。</p><h5 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="(4)建立一个公共溢出区"></a>(4)建立一个公共溢出区</h5><p>​        将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><h4 id="3-HashMap-HaspTable-ConcurrentHaspMap的区别"><a href="#3-HashMap-HaspTable-ConcurrentHaspMap的区别" class="headerlink" title="3.HashMap,HaspTable,ConcurrentHaspMap的区别"></a>3.HashMap,HaspTable,ConcurrentHaspMap的区别</h4><h5 id="1-haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap"><a href="#1-haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap" class="headerlink" title="(1)haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap."></a>(1)haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap.</h5><h5 id="2-hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。"><a href="#2-hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。" class="headerlink" title="(2)hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。"></a>(2)hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。</h5><h5 id="3-concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。"><a href="#3-concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。" class="headerlink" title="(3)concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。"></a>(3)concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java子父类构造器的调用</title>
    <link href="http://yoursite.com/2020/05/13/java%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/13/java%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2020-05-13T02:15:32.000Z</published>
    <updated>2020-05-13T02:27:46.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​        在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。</p><h5 id="子父类代码执行顺序"><a href="#子父类代码执行顺序" class="headerlink" title="子父类代码执行顺序"></a>子父类代码执行顺序</h5><p>父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p><p>案例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;  System.out.println(<span class="string">"父类静态代码块"</span>);    &#125;</span><br><span class="line"></span><br><span class="line">        &#123; System.out.println(<span class="string">"父类非静态代码块"</span>);  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;  System.out.println(<span class="string">"父类构造函数"</span>);    &#125;   </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;  System.out.println(<span class="string">"子类静态代码块"</span>);    &#125;</span><br><span class="line"></span><br><span class="line">      &#123;  System.out.println(<span class="string">"子类非静态代码块"</span>);    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"子类构造函数"</span>);    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">结果为：   父类静态代码块</span><br><span class="line">           子类静态代码块</span><br><span class="line">           父类非静态代码块</span><br><span class="line">           父类构造函数</span><br><span class="line">           子类非静态代码块</span><br><span class="line">           子类构造函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线程的五大状态及其转换</title>
    <link href="http://yoursite.com/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-13T02:00:06.000Z</published>
    <updated>2020-05-13T02:19:26.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p> resume与suspended一起使用 </p><p>wait与notify(notifyAll)一起使用</p><p>sleep会让线程暂时不执行 </p><p>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态。    </p><p>线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。    </p><p>各线程之间的转换如下图：</p><img src="/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/p1.png" class title="线程之间的转换"><p> <strong>1.新建状态(New)：</strong> 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</p><p>   <strong>2.就绪状态(Runnable)：</strong>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。</p><p> 当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，</p><p> 并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p><p> 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU</p><p> 时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能</p><p> 同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个</p><p> 线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度</p><p> 程序(thread scheduler)来调度的。    </p><p><strong>3.运行状态(Running)：</strong>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.    </p><p><strong>4.阻塞状态(Blocked)：</strong></p><p> 线程运行过程中，可能由于各种原因进入阻塞状态: 1&gt;线程通过调用sleep方法进入睡眠状态； 2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； 3&gt;线程试图得到一个锁，而该锁正被其他线程持有； 4&gt;线程在等待某个触发条件； ……</p><p> 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间， 进入运行状态。    </p><p><strong>5.死亡状态(Dead)</strong></p><p> 有两个原因会导致线程死亡：      </p><p>（1）run方法正常退出而自然死亡，</p><p>（2）一个未捕获的异常终止了run方法而使线程猝死。</p><p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是 可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了， 则返回false.     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java创建对象的几种方式</title>
    <link href="http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-12T14:59:42.000Z</published>
    <updated>2020-05-13T01:58:49.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="java有5种方式来创建对象："><a href="#java有5种方式来创建对象：" class="headerlink" title="java有5种方式来创建对象："></a>java有5种方式来创建对象：</h4><p>1、使用 new 关键字（最常用）： <code>ObjectName obj = new ObjectName();</code></p><p>2、使用反射的Class类的newInstance()方法：<code>ObjectName obj = ObjectName.class.newInstance();</code></p><p>3、使用反射的Constructor类的newInstance()方法： <code>ObjectName obj = ObjectName.class.getConstructor.newInstance();</code></p><p> 4、使用对象克隆clone()方法：<code>ObjectName obj = obj.clone();</code></p><p>5、使用反序列化（ObjectInputStream）的readObject()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(FILE_NAME))) &#123; ObjectName obj = ois.readObject(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的五大基本原则</title>
    <link href="http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-05-12T14:55:21.000Z</published>
    <updated>2020-05-12T14:58:35.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h4><p><strong>单一职责原则（Single-Resposibility Principle）：</strong></p><p>一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p><p><strong>开放封闭原则（Open-Closed principle）：</strong></p><p>软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 </p><p><strong>Liskov替换原则（Liskov-Substituion Principle）：</strong></p><p>子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 </p><p><strong>依赖倒置原则（Dependecy-Inversion Principle）：</strong></p><p>依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 </p><p><strong>接口隔离原则（Interface-Segregation Principle）：</strong></p><p>使用多个小的专门的接口，而不要使用一个大的总接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有关java基本类型的默认值和取值范围</title>
    <link href="http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</id>
    <published>2020-05-12T14:40:37.000Z</published>
    <updated>2020-05-12T14:52:32.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​        </p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th><th align="center">取值范围</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">0</td><td align="center">-2^7—-2^7-1</td><td align="center">byte b=10;</td></tr><tr><td align="center">字符型</td><td align="center">\u0000</td><td align="center">0—-2^16-1</td><td align="center">char c=’c’;</td></tr><tr><td align="center">short</td><td align="center">0</td><td align="center">-2^15—-2^15-1</td><td align="center">short s=10;</td></tr><tr><td align="center">int</td><td align="center">0</td><td align="center">-2^31—-2^31-1</td><td align="center">int i=10;</td></tr><tr><td align="center">long</td><td align="center">0</td><td align="center">-2^63—-2^63-1</td><td align="center">long o=10L;</td></tr><tr><td align="center">float</td><td align="center">0.0f</td><td align="center">-2^31—-2^31-1</td><td align="center">float f=10.0F</td></tr><tr><td align="center">double</td><td align="center">0.0d</td><td align="center">-2^63—-2^63-1</td><td align="center">double d=10.0;</td></tr><tr><td align="center">boolean</td><td align="center">false</td><td align="center">true\false</td><td align="center">boolean flag=true;</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的强制类型转换</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-12T14:35:48.000Z</published>
    <updated>2020-05-12T14:39:59.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a"><a href="#经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a" class="headerlink" title="经过强制类型转换以后，变量a, b的值分别为（128 -128 ）short a = 128; byte b = (byte) a;"></a>经过强制类型转换以后，变量a, b的值分别为（128 -128 ）<code>short a = 128; byte b = (byte) a;</code></h4><p>1、Java中用补码形式表示</p><p>2、第一位正负位，1表示负，0表示正。</p><p>3、原码：一个数的二进制表示。</p><p>​         3的原码00000011  -3的 原码 10000011</p><p>4、反码：负数原码按位取反（符号位不变）。正数原码本身。</p><p>​        3的反码00000011  -3的反码11111100</p><p>5、补码：正数是原码本身。负数反码加1。</p><p>​         3的补码是00000011 -3的补码是11111101</p><p>-——————————————————————————</p><p>int占4个字节，32位</p><p>byte占1个字节，8位</p><p>所以强转时会截断。前24位</p><p>-————————————————————————–</p><p>在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：</p><p>int a = 3     00000000 00000000 00000000 00000011 （强转byte时前面24个0被截断）</p><p>byte b = 3   00000011</p><p>int a = -3    11111111 11111111  11111111  11111101 （强转byte时前面24个1被截断）</p><p>byte b = -3   11111101</p><p>-—————————————————————————</p><p>已知负数的补码，求负数：</p><p>补码-1=反码，反码按位取反=该负数绝对值</p><p>已知负数，求负数的补码：</p><p>1、负数原码除了符号位，按位取反（不含符号位），加1。</p><p>2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1</p><p>-——————————————————————————</p><p>例子：</p><p>java int 128转为byte，值：</p><p>128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的构造方法</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-12T14:12:29.000Z</published>
    <updated>2020-05-12T14:31:39.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。<br> 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。详见：<a href="http://blog.csdn.net/welcome000yy/article/details/8941644" target="_blank" rel="noopener">http://blog.csdn.net/welcome000yy/article/details/8941644</a><br> 接口里面的变量为常量，其实际是 public static final ；接口里面的方法为抽象方法，其实际是public abstract。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的classloader类加载器</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-05-12T13:00:57.000Z</published>
    <updated>2020-05-12T14:09:24.699Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>JDK中提供了三个ClassLoader，根据层级从高到低为：</p><p>1.Bootstrap ClassLoader，（根加载器）主要加载JVM自身工作需要的类。</p><p>2.Extension ClassLoader，（扩展类加载器）主要加载%JAVA_HOME%\lib\ext目录下的库类。</p><p>3.Application ClassLoader，（系统类加载器）主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</p><p>即使同一个名，用了不同的类加载器就判定为不同的类</p><p>JVM加载类的实现方式，我们称为 <strong>双亲委托模型</strong>：</p><p>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。</p><p><strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong></p><p>假设有一个开发者自己编写了一个名为Java<em>.lang.Object</em>的类，想借此欺骗JVM。现在他要使用<strong>自定义ClassLoader</strong>来加载自己编写的<em>java.lang.Object</em>类。然而幸运的是，<strong>双亲委托模型</strong>不会让他成功。因为JVM会优先在<strong>Bootstrap ClassLoader</strong>的路径下找到<em>java.lang.Object</em>类，并载入它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的种类以及辨析</title>
    <link href="http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/</id>
    <published>2020-05-12T12:55:32.000Z</published>
    <updated>2020-05-12T12:59:53.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。"><a href="#锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。" class="headerlink" title="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。"></a>锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。</h5><p>1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p><p>2、阻塞锁 被阻塞的线程，不会争夺锁。</p><p>3、可重入锁 多次进入改锁的域</p><p>4、读写锁</p><p>5、互斥锁 锁本身就是互斥的</p><p>6、悲观锁 不相信，这里会是安全的，必须全部上锁</p><p>7、乐观锁 相信，这里是安全的。</p><p>8、公平锁 有优先级的锁</p><p>9、非公平锁 无优先级的锁</p><p>10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p><p>11、对象锁 锁住对象</p><p>12、线程锁</p><p>13、锁粗化 多锁变成一个，自己处理</p><p>14、轻量级锁 CAS 实现</p><p>15、锁消除 偏向锁就是锁消除的一种</p><p>16、锁膨胀 jvm实现，锁粗化</p><p>17、信号量 使用阻塞锁 实现的一种策略</p><p>18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么操作会使得当前线程停止？</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/</id>
    <published>2020-05-12T12:38:45.000Z</published>
    <updated>2020-05-12T12:44:10.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A：一个InterruptedException 异常被捕获 大家都知道的嘛 （一般通过interrupt方法 中断线程） 如果抓到一个线程 都会关进catch里面 然后中断当前操作。</p><p>B：线程执行了wait()方法。  线程使用了wait方法，会强行打断当前操作，（暂停状态，不会中断线程） 进入阻塞（暂停）状态，然后需要notify方法或notifyAll方法才能进入就绪状态。</p><p>C：当前线程创建了一个新的线程。  新创建的线程不会抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。</p><p>D：一个高优先级别的线程就绪。 如C相同，你优先级别再高 也待等我现在弄完才会给你。</p><p>E：线程在MediaTracker上执行了waitforID（）调用。 </p><p>这个类是awt里面的，他的功能是加载图像，直到完成之前，该方法一直等待！这个方法是必须要抛出A选项的InterruptedException 异常的 说明这玩意会让其他线程 wait他完成！  所以会暂停当前线程~~大概是这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java的反射</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/</id>
    <published>2020-05-12T12:24:53.000Z</published>
    <updated>2020-05-12T12:37:21.860Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>反射指的是在运行时能够分析类的能力的程序。</p><p>反射机制可以用来：</p><p>1.在运行时分析类的能力–检查类的结构–所用到的就是<strong>java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的域、方法和构造器</strong>。</p><p>2.在运行时查看对象。</p><p>3.实现通用的数组操作代码。</p><p><strong>反射机制的功能：</strong></p><p>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态方法。</p><p><strong>反射机制常见作用：</strong></p><p>动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。</p><p><strong>反射机制性能问题：</strong></p><p>反射会降低效率。</p><p>void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。禁止安全检查，可以提高反射的运行速度。</p><p>可以考虑使用：cglib/javaassist操作。</p><p> Java语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象(根据安全性限制)，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。Java reflection非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。Java的这一特性非常强大，并且是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。</p><p>   但反射有两个缺点。第一个是性能问题。用于字段和方法接入时反射要远慢于直接代码。性能问题的程度取决于程序中是如何使用反射的。如果它作为程序运行中相对很少涉及的部分，缓慢的性能将不会是一个问题。即使测试中最坏情况下的计时图显示的反射操作只耗用几微秒。仅反射在性能关键的应用的核心逻辑中使用时性能问题才变得至关重要。</p><p>   许多应用中更严重的一个缺点是使用反射会模糊程序内部实际要发生的事情。程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术会带来维护问题。反射代码比相应的直接代码更复杂，正如性能比较的代码实例中看到的一样。解决这些问题的最佳方案是保守地使用反射一-仅在它可以真正增加灵活性的地方一记录其在 目标类中的使用。</p><p>   Reflection是Java程序开发语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说”自审”，并能直接操作程序的内部属性。例如，使用它能获得Java类中各成员的名称并显示出来。</p><p>   Java的这-能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一-特性。例如，Pascal. C或者C++中就没有办法在程序中获得函数定义相关的信息。</p><p>   JavaBean是reflection的实际应用之一，它能让一些工具可视化的操作软件组件。这些工具通过reflection动态的载入并取得Java组件(类)的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的关键字与保留字</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/</id>
    <published>2020-05-12T12:21:57.000Z</published>
    <updated>2020-05-12T12:24:26.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Java关键字是<a href="https://baike.baidu.com/item/电脑语言/7105622" target="_blank" rel="noopener">电脑语言</a>里事先定义的，有特别意义的标识符，有时又叫<a href="https://baike.baidu.com/item/保留字/7674788" target="_blank" rel="noopener">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><p> java中true ,false , null在java中不是关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符。</p><p>其中const和goto是java的保留字。java中所有的关键字都是小写的，还有要注意true,false,null,　friendly，sizeof不是java的关键字,但是你不能把它们作为java标识符用。</p><p>goto和const是保留字也是关键字。</p><p>关键字列表 (依字母排序 共50组)：</p><p>abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）, continue, default, do, double, else, enum, extends, final, finally, float, for, goto（保留关键字）, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while</p><p>保留字列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：</p><p>byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto （保留关键字） , const （保留关键字） , null</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于ArrayLinst与LinkList</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/</id>
    <published>2020-05-12T11:33:30.000Z</published>
    <updated>2020-05-12T11:42:07.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p><p>- ———————————————————————</p><p>B. 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p><p>-———————————————————————-</p><p>C. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p><p>-————————————————————————</p><p>D. ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针，所以，你懂的。</p><p>下面放一张ArrayList和LinkedList的区别表：</p><img src="/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/p1.png" class title="ArrayList和LinkedList的区别表">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于java内存区域</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-05-12T11:26:47.000Z</published>
    <updated>2020-05-12T11:31:43.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；</p><p>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中</p><p>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组</p><p>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>二叉树查找的时间复杂度</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2020-05-12T11:22:50.000Z</published>
    <updated>2020-05-12T11:25:39.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="二叉树查找的时间复杂度"><a href="#二叉树查找的时间复杂度" class="headerlink" title="二叉树查找的时间复杂度"></a>二叉树查找的时间复杂度</h4><p>​        给定值的比较次数等于给定值节点在二叉排序树中的层数。如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
