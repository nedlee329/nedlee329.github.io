<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ned Lee&#39;s bolg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-26T08:45:18.310Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ned Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-05-26T07:08:15.000Z</published>
    <updated>2020-05-26T08:45:18.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="分层的概念"><a href="#分层的概念" class="headerlink" title="分层的概念"></a><center>分层的概念</center></h1><h3 id="问题-1：OSI-有哪几层，会画出来，知道主要几层的各自作用"><a href="#问题-1：OSI-有哪几层，会画出来，知道主要几层的各自作用" class="headerlink" title="问题 1：OSI 有哪几层，会画出来，知道主要几层的各自作用"></a>问题 1：OSI 有哪几层，会画出来，知道主要几层的各自作用</h3><ol><li><p>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</p></li><li><p>表示层（数据）：主要解决拥护信息的语法表示问题，如加密解密</p></li><li><p>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的</p></li><li><p>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等</p></li><li><p>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输</p></li><li><p>数据链路层（帧）：将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正</p></li><li><p>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等</p></li></ol><h3 id="问题-2：知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）"><a href="#问题-2：知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）" class="headerlink" title="问题 2：知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）"></a>问题 2：知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）</h3><ol><li><p>网关：应用层、传输层（网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连）</p></li><li><p>路由器：网络层（路由选择、存储转发）</p></li><li><p>交换机：数据链路层、网络层（识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中）</p></li><li><p>网桥：数据链路层（将两个 LAN 连起来，根据 MAC 地址来转发帧）</p></li><li><p>集线器（Hub）：物理层（纯硬件设备，主要用来连接计算机等网络终端）</p></li><li><p>中继器：物理层（在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离）</p></li></ol><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><center>数据链路层</center></h1><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><h3 id="问题-1：ARP-的作用？"><a href="#问题-1：ARP-的作用？" class="headerlink" title="问题 1：ARP 的作用？"></a>问题 1：ARP 的作用？</h3><p>ARP 为 IP 地址到对应的硬件地址提供动态映射。</p><h3 id="问题-2：点对点链路使用-ARP-吗？"><a href="#问题-2：点对点链路使用-ARP-吗？" class="headerlink" title="问题 2：点对点链路使用 ARP 吗？"></a>问题 2：点对点链路使用 ARP 吗？</h3><p>不使用 </p><h3 id="问题-3：ARP-高效运行的关键是什么？"><a href="#问题-3：ARP-高效运行的关键是什么？" class="headerlink" title="问题 3：ARP 高效运行的关键是什么？"></a>问题 3：ARP 高效运行的关键是什么？</h3><p>关键是每个主机上都有一个 ARP 的高速缓存。</p><h3 id="问题-4：ARP-报文的各个字段以及含义？"><a href="#问题-4：ARP-报文的各个字段以及含义？" class="headerlink" title="问题 4：ARP 报文的各个字段以及含义？"></a>问题 4：ARP 报文的各个字段以及含义？</h3> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/arp.png" class title="ARP 报文的各个字段以及含义"><p>帧类型：ARP：0x0806 （2） </p><p>ARP 首部：</p><p>硬件类型：硬件地址的类型，1 表示以太网地址。（2） </p><p>协议类型：协议地址的类型，0x0800 表示 IP 地址。(2) </p><p>硬件地址长度：字节为单位 6  （1）</p><p>协议地址长度：字节为单位 4  (1)</p><p>操作类型：2 个字节。 ARP 请求 1，ARP 回复 2，RARP 请求 3，RARP 应答 4。（2） </p><p>发送者硬件地址：6 个字节（6）</p><p>发送者 IP 地址：4 个字节（4） </p><p>目标硬件地址：6 个字节（6） </p><p>目标 IP 地址：4 个字节（4） </p><p>CRC 校验：4 个字节 （4）</p><p>总结：</p><p>arp 总共 28 个字节。</p><p>记忆方法： 以太网先目地后源，ARP 先发送端后目地端。先硬件后协议。</p><h3 id="问题-5：ARP-协议有什么弱点？"><a href="#问题-5：ARP-协议有什么弱点？" class="headerlink" title="问题 5：ARP 协议有什么弱点？"></a>问题 5：ARP 协议有什么弱点？</h3><p>1） 缓存：主机的地址映射是基于高速缓存的，动态更新的。地址刷新是有时间限制的。 可以通过下次更新之前修改计算机上的地址缓存，造成拒绝服务攻击或者 ARP 欺骗。</p><p>2） 广播: 攻击者可以伪装 ARP 应答。</p><p>3） ARP 应答没有认证，都是合法的。可以在不接受到请求的时候就发出应答包。</p><h3 id="问题-6：ARP-代理的概念和应用场景"><a href="#问题-6：ARP-代理的概念和应用场景" class="headerlink" title="问题 6：ARP 代理的概念和应用场景"></a>问题 6：ARP 代理的概念和应用场景</h3><p>若 ARP 请求是从一个网络的主机发送给另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程叫做 ARP 代理。ARP 代理路由器响应 ARP 请求的 MAC 地址为路由器的 MAC 地址而非 ARP 请求的主机的 MAC 地址。</p><p>ARP 代理的应用环境：</p><p>两个物理网络之间的路由是使用相同的网络号，两个路由器设置成 ARP 代理，实现相互隐瞒物理网络</p><h3 id="问题-7：免费-ARP"><a href="#问题-7：免费-ARP" class="headerlink" title="问题 7：免费 ARP"></a>问题 7：免费 ARP</h3><p>指主机发送 ARP 查找自己的 IP 地址，即数据链路层 SIP=DIP作用有两个：</p><p>1） 一个主机使用免费 ARP 确定是有存在有其他主机设置了相同的IP 地址</p><p>2） 如果发送免费 ARP 的主机改变了 MAC 地址，可以通过发送免费 ARP 的方式告知其他主机端更新 ARP 表</p><h3 id="问题-8：数据链路层-MTU-的最大值和最小值是多少？"><a href="#问题-8：数据链路层-MTU-的最大值和最小值是多少？" class="headerlink" title="问题 8：数据链路层 MTU 的最大值和最小值是多少？"></a>问题 8：数据链路层 MTU 的最大值和最小值是多少？</h3><p>1) 数据链路层的<strong>最小MTU 为64字节</strong>。对于IEEE802.3，两个站点的最远距离不超过2500m,由 4 个中继器连接而成，其冲突窗口为 51.2us(2 倍电缆传播延迟加上 4 个中继器的双向延迟).对于 10Mbps 的 IEEE802.3 来说，这个时间等于发送 64 字节，即 512 位的时间，64 字节就是由此而来的。如果一个站点已经传输了 512bit，就认为它已经占用了这个信道。</p><p>2) 数据链路层的<strong>最大</strong> <strong>MTU 为 1500 字节</strong>，即数据字段的最大长度</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><center>网络层</center></h1><h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><h3 id="问题-1：如何理解IP-的不可靠和无连接。"><a href="#问题-1：如何理解IP-的不可靠和无连接。" class="headerlink" title="问题 1：如何理解IP 的不可靠和无连接。"></a>问题 1：如何理解IP 的不可靠和无连接。</h3><p><strong>不可靠</strong>：指的是不能保证数据报能成功地到达目的地。</p><p>发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端。 可靠性由上层提供。</p><p><strong>无连接</strong>：IP 不维护关于后续数据报的状态信息。</p><p>体现在，IP 数据可以不按顺序发送和接收。A 发送连续的数据报，到达B 不一定是连续的， 来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。</p><h3 id="问题-2：IP-报文的格式和各个字段的含义。"><a href="#问题-2：IP-报文的格式和各个字段的含义。" class="headerlink" title="问题 2：IP 报文的格式和各个字段的含义。"></a>问题 2：IP 报文的格式和各个字段的含义。</h3> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ip.png" class title="IP 报文的格式和各个字段的含义"> <p><strong>版本号</strong>： IPV4 就是 4，IPV6 就是 6 （4）</p><p><strong>首部长度</strong>：4 个字节为单位。最小为 5，最大为 15。所以最小长度 20 个字节，最大为 60个字节。（4）</p><p><strong>服务类型</strong>： Qos 用，目前不怎么使用。（8）</p><p><strong>总长度</strong>：字节为单位。 最多可以传送 65535 字节的IP 数据包。（16） <strong>标识字段</strong>（8）</p><p><strong>标 志</strong> （3）</p><p><strong>段偏移</strong>（5）与分片有关。</p><p><strong>生存时间 TTL</strong>：经过一个路由器减一。 字段为 0 时，数据报被丢弃，并且发送 ICMP 报文通知源主机。目的是防止数据报在选路时无休止地在网络中流动。（8） </p><p><strong>协议</strong>：区分上层协议 （8）</p><p><strong>首部校验和</strong>：仅对首部进行校验。（16）【对比： ICMP，IGMP，TCP，UDP：对首部和数据进行校验】</p><p><strong>源地址</strong>：（32）</p><p><strong>目的地址</strong>：(32)</p><h3 id="问题-3：为什么-IP-首部中要有总长度字段？"><a href="#问题-3：为什么-IP-首部中要有总长度字段？" class="headerlink" title="问题 3：为什么 IP 首部中要有总长度字段？"></a>问题 3：为什么 IP 首部中要有总长度字段？</h3><p>因为一些数据链路（以太网）需要填充一些数据以达到最小长度。因为以太网帧的最小长度是 46 个字节，但是IP 长度可能更短，所以需要总长度来确定IP 数据部分的内容。</p><h3 id="问题-4：IP-首部校验和怎么计算的，与-ICMP，IGMP，TCP，UDP-的首部校验和有什么区别与共同点？"><a href="#问题-4：IP-首部校验和怎么计算的，与-ICMP，IGMP，TCP，UDP-的首部校验和有什么区别与共同点？" class="headerlink" title="问题 4：IP 首部校验和怎么计算的，与 ICMP，IGMP，TCP，UDP 的首部校验和有什么区别与共同点？"></a>问题 4：IP 首部校验和怎么计算的，与 ICMP，IGMP，TCP，UDP 的首部校验和有什么区别与共同点？</h3><p>（1） 先把校验和字段置 0。</p><p>（2） 对首部中每个 16 位比特进行二进制反码求和。</p><p>（3） 结果存在检验和字段中。</p><p>（4） 收到一份 IP 数据包后，同样对首部中每个 16bit 二进制反码求和。</p><p>（5） 最后结果全为 1，表示正确，否则表示错误。</p><p>（6） 如果是错误的，IP 就丢弃该数据报，但是不生成差错报文，由上层去处理。</p><p>共同点：用到的算法都是一样的。</p><p>区别：IP 计算的时候没有将数据包括在内。ICMP，IGMP，TCP，UDP 同时覆盖首部和数据检验码。</p><h3 id="问题-5：主机和路由器本质区别是？"><a href="#问题-5：主机和路由器本质区别是？" class="headerlink" title="问题 5：主机和路由器本质区别是？"></a>问题 5：主机和路由器本质区别是？</h3><p>主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。</p><h3 id="问题-6：IP-路由选择的过程是怎么样的？"><a href="#问题-6：IP-路由选择的过程是怎么样的？" class="headerlink" title="问题 6：IP 路由选择的过程是怎么样的？"></a>问题 6：IP 路由选择的过程是怎么样的？</h3><p>根据最长匹配原则，找到条目，发送到指定的路由器。如果不能找到，返回一个“主机不可达”或“网络不可达”的错误。</p><h3 id="问题-7：IP-路由选择的特性有什么？"><a href="#问题-7：IP-路由选择的特性有什么？" class="headerlink" title="问题 7：IP 路由选择的特性有什么？"></a>问题 7：IP 路由选择的特性有什么？</h3><p>（１） IP 路由选择是逐跳进行的。</p><p>IP 并不知道到达任何目的的完整路径，只提供下一跳地址。</p><p>（２） 为一个网络指定一个路由器，而不是为每个主机指定一个路由器。这样可以缩小路由表规模。</p><h3 id="问题-8：IP-搜索路由表的步骤"><a href="#问题-8：IP-搜索路由表的步骤" class="headerlink" title="问题 8：IP 搜索路由表的步骤"></a>问题 8：IP 搜索路由表的步骤</h3><p>搜索匹配的主机地址 —-》搜索匹配的网络地址– 》搜索默认选项</p><p>IP 层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。</p><h3 id="问题-9：如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？"><a href="#问题-9：如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？" class="headerlink" title="问题 9：如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？"></a>问题 9：如果路由表中没有默认项，而又没有找到匹配项，这时如何处理？</h3><p>结果取决于该 IP 数据报是由主机产生的还是被转发的。</p><p>如果数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。</p><p>如果是被转发的数据报，就给原始发送一份 ICMP 主机不可达的差错报文。</p><h3 id="问题-10：IP-地址的分类，如何划分的，及会计算各类地址支持的主机数"><a href="#问题-10：IP-地址的分类，如何划分的，及会计算各类地址支持的主机数" class="headerlink" title="问题 10：IP 地址的分类，如何划分的，及会计算各类地址支持的主机数"></a>问题 10：IP 地址的分类，如何划分的，及会计算各类地址支持的主机数</h3><ol><li><p>A 类地址：首位为 0，1.0.0.1~~126.255.255.254；主机号 24 位</p></li><li><p>B 类地址：首位为 10，128.0.0.1~~191.255.255.254；主机号 16 位</p></li><li><p>C 类地址：首位为 110，192.0.0.1~~223.255.255.254；主机号 8 位</p></li><li><p>D 类地址（多播地址，也叫做组播地址）：首位为 1110，224.0.0.1~~239.255.255.254</p></li><li><p>E 类地址：此类地址是保留地址，首位为 11110，240.0.0.1~~254.255.255.254 </p></li></ol><h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><h3 id="问题-1：ICMP-的层次和作用。"><a href="#问题-1：ICMP-的层次和作用。" class="headerlink" title="问题 1：ICMP 的层次和作用。"></a>问题 1：ICMP 的层次和作用。</h3><img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/icmpd.png" class title="ICMP的层次和作用"> <p>ICMP 一般认为是在三层的。主要传递一些差错报文和其他需要注意的信息。</p><h3 id="问题-2：ICMP-报文的分类？"><a href="#问题-2：ICMP-报文的分类？" class="headerlink" title="问题 2：ICMP 报文的分类？"></a>问题 2：ICMP 报文的分类？</h3><p>ICMP 分为两类，一类是 ICMP 查询报文，另一类是 ICMP 差错报文。</p><img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/icmp.png" class title="ICMP 报文的分类"><h3 id="问题-3：ICMP-的主机不可达报文是在什么情况下发出的？"><a href="#问题-3：ICMP-的主机不可达报文是在什么情况下发出的？" class="headerlink" title="问题 3：ICMP 的主机不可达报文是在什么情况下发出的？"></a>问题 3：ICMP 的主机不可达报文是在什么情况下发出的？</h3><p>三层设备（路由器）给该主机寻路时，没有找到相应路径，向源 IP 发回 ICMP 主机不可达</p><h3 id="问题-4：什么情况不会导致产生-ICMP-差错报文？-1）-ICMP-差错报文。"><a href="#问题-4：什么情况不会导致产生-ICMP-差错报文？-1）-ICMP-差错报文。" class="headerlink" title="问题 4：什么情况不会导致产生 ICMP 差错报文？ 1） ICMP 差错报文。"></a>问题 4：什么情况不会导致产生 ICMP 差错报文？ 1） ICMP 差错报文。</h3><p>2）   目的地址是广播地址或者多播地址的 IP 数据报。</p><p>3）   链路层广播的数据报</p><p>4）   不是 IP 分片的第一片</p><p>5）   源地址不是单个主机的数据包。</p><h3 id="问题-5：ICMP-重定向差错报文是怎么来的，在何种场合出现？"><a href="#问题-5：ICMP-重定向差错报文是怎么来的，在何种场合出现？" class="headerlink" title="问题 5：ICMP 重定向差错报文是怎么来的，在何种场合出现？"></a>问题 5：ICMP 重定向差错报文是怎么来的，在何种场合出现？</h3> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/r1.jpg" class title="ICMP 重定向差错报文"><p>1）   主机发送 IP 数据报给 R1，因为主机的默认路由指向的下一跳是 R1。</p><p>2）   R1 收到数据报并且检查它的路由表，发现 R2 是发送该数据报的下一跳。当他将数据报发送给 R2 的时候，发现发送的接口与接受的端口是一样的，因此同时发送一个 ICMP 重定向报文给主机。</p><p>3）   R1 接受到 ICMP 重定向报文后，接下来的数据报就发送给 R2，而不再发送给 R1。</p><p><strong>问题 6：重定向报文有什么规则？</strong> </p><p>重定向报文只能有路由器生成。</p><p>重定向报文是为主机而不是为路由器使用的。</p><h3 id="问题-7：Ping-命令的具体过程是怎么样的？"><a href="#问题-7：Ping-命令的具体过程是怎么样的？" class="headerlink" title="问题 7：Ping 命令的具体过程是怎么样的？"></a>问题 7：Ping 命令的具体过程是怎么样的？</h3><p>参考文章：《对于 Ping 的过程，你真的了解吗？》 <a href="https://mp.weixin.qq.com/s/DfQT3Vw2xaq60YIil-7Yxw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DfQT3Vw2xaq60YIil-7Yxw</a></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><center>传输层</center></h1><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><h3 id="问题-1：UDP-和-TCP-的简单介绍。"><a href="#问题-1：UDP-和-TCP-的简单介绍。" class="headerlink" title="问题 1：UDP 和 TCP 的简单介绍。"></a>问题 1：UDP 和 TCP 的简单介绍。</h3><p>UDP 是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个 UDP 数据报，并组装成一份待发送的 IP 数据报。</p><p>TCP 是面向流字符，应用程序产生的全体数据与真正发送的单个 IP 数据报可能没什么联系。</p><h3 id="问题-2：UDP-报头字段和含义？"><a href="#问题-2：UDP-报头字段和含义？" class="headerlink" title="问题 2：UDP 报头字段和含义？"></a>问题 2：UDP 报头字段和含义？</h3> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/udpb.png" class title="UDP 首部"><p>源端口号（2） </p><p>目地端口号（2）</p><p>UDP 长度：是UDP 的报文总长度，是多于的。 IP 总长度减去首部长度就是此值。（2） </p><p>UDP 校验和：注意点：校验和是可选的。 （TCP 是必选的）校验和覆盖 UDP 首部和数据</p><p>（TCP 也一样覆盖首部和数据，但是 IP 指覆盖首部）（2）</p><h3 id="问题-3：-UDP-的校验和是怎么计算的？"><a href="#问题-3：-UDP-的校验和是怎么计算的？" class="headerlink" title="问题 3： UDP 的校验和是怎么计算的？"></a>问题 3： UDP 的校验和是怎么计算的？</h3><p>UDP 的校验和要计算首部和数据部分。首部还包括伪首部。</p>   <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/udp.png" class title="UDP 的校验和计算"><p>多了 12 个字节的伪首部。</p><p>注意点：UDP 长度计算两次。</p><p>如果检验和有错，则 UDP 数据报被悄悄丢弃，不产生任何差错报文。</p><h3 id="问题-4：为什么要加有伪首部？"><a href="#问题-4：为什么要加有伪首部？" class="headerlink" title="问题 4：为什么要加有伪首部？"></a>问题 4：为什么要加有伪首部？</h3><p>目的是让UDP 两次检查数据是否已经正确到达目的地。IP 接受正确的目的地址，传送到正确的上层程序。</p><p>所有伪首部包括：源 IP 地址，目的 IP 地址，0，协议号，UDP 长度。</p><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="问题-1：TCP-通过哪些方式来保证可靠性？"><a href="#问题-1：TCP-通过哪些方式来保证可靠性？" class="headerlink" title="问题 1：TCP 通过哪些方式来保证可靠性？"></a>问题 1：TCP 通过哪些方式来保证可靠性？</h3><p>1）   应用数据被分割成 TCP 认为最适合发送的数据块。</p><p>2）   确认机制，发送报文后，等待确认。</p><p>3）   重发机制，没有收到确认，将重发数据段。</p><p>4）   保持它首部和数据的校验和。确认数据的准确性。</p><p>5）   排序，丢弃重复的，流量控制。</p><h3 id="问题-2：TCP-与-UDP-的概念相互的区别及优劣"><a href="#问题-2：TCP-与-UDP-的概念相互的区别及优劣" class="headerlink" title="问题 2：TCP 与 UDP 的概念相互的区别及优劣"></a>问题 2：TCP 与 UDP 的概念相互的区别及优劣</h3><ol><li>TCP 面向连接，UDP 面向无链接</li></ol><ol start="2"><li>TCP 面向报文，UDP 面向字节流</li></ol><ol start="3"><li>TCP 提供可靠传输服务（数据顺序、正确性），UDP 传输不可靠</li></ol><ol start="4"><li>TCP 协议传输速度慢，UDP 协议传输速度快</li></ol><ol start="5"><li>TCP 协议对系统资源要求多（头部开销大），UDP 协议要求少</li></ol><h3 id="问题-3：TCP、UDP-为什么存在伪包头？"><a href="#问题-3：TCP、UDP-为什么存在伪包头？" class="headerlink" title="问题 3：TCP、UDP 为什么存在伪包头？"></a>问题 3：TCP、UDP 为什么存在伪包头？</h3><p>UDP(TCP)检验和：是根据 UDP(TCP)数据报和伪报头计算得到的差错检测值。</p><p>伪报头包含源和目的 IP 地址，以及来自 IP 数据报报头的协议值。IP 数据报在网络中传送时包含UDP 数据报。</p><p>伪报头并不会在网络中传送，校验和中所包含的伪报头内容可以避免目的端错误地接收错误路由的数据报。校验和值的计算方法和 IP 报头检验和的计算方法类似</p><h3 id="问题-4：为什么要-3-次握手，4-次挥手"><a href="#问题-4：为什么要-3-次握手，4-次挥手" class="headerlink" title="问题 4：为什么要 3 次握手，4 次挥手"></a>问题 4：为什么要 3 次握手，4 次挥手</h3><ol><li><p>3 次握手：防止已过期的连接请求报文突然又传送到服务器，因而产生错误</p></li><li><p>4 次挥手：确保数据能够完成传输，但关闭连接时，当收到对方的FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的 </p></li></ol><h3 id="问题-5：TCP-的流量控制机制"><a href="#问题-5：TCP-的流量控制机制" class="headerlink" title="问题 5：TCP 的流量控制机制"></a>问题 5：TCP 的流量控制机制</h3><p>主要是下面的四种机制：</p><p> <strong>慢启动（慢开始）：</strong></p><ol><li><p>慢开始不是指 cwnd 的增长速度慢（指数增长），而是指 TCP 开始发送设置 cwnd=1。</p></li><li><p>思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。</p></li><li><p>为了防止 cwnd 增长过大引起网络拥塞，设置一个慢开始门限（ssthresh 状态变量）</p><p>当 cnwd＜ssthresh，使用慢开始算法</p><p>当 cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</p><p>当 cnwd＞ssthresh，使用拥塞避免算法</p></li></ol><h2 id><a href="#" class="headerlink" title></a></h2><h3 id="拥塞避免："><a href="#拥塞避免：" class="headerlink" title="拥塞避免："></a>拥塞避免：</h3><ol><li><p>拥塞避免并非完全能够避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p></li><li><p>思路：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞控制窗口加一。</p></li></ol><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为 1，执行慢开始算法。 如图所示：</p>  <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/yong.png" class title="拥塞避免"><h3 id="快速重传："><a href="#快速重传：" class="headerlink" title="快速重传："></a>快速重传：</h3><ol><li><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p></li><li><p>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</p></li></ol><h3 id="快速恢复："><a href="#快速恢复：" class="headerlink" title="快速恢复："></a>快速恢复：</h3><ol><li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。但是接下去并不执行慢开始算法。</p></li><li><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。</p><img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/quick.png" class title="快速恢复"></li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><center>应用层</center></h1><h3 id="问题-1：DNS-的概念，用途，DNS-查询的实现算法"><a href="#问题-1：DNS-的概念，用途，DNS-查询的实现算法" class="headerlink" title="问题 1：DNS 的概念，用途，DNS 查询的实现算法"></a>问题 1：DNS 的概念，用途，DNS 查询的实现算法</h3><ul><li><p>概念</p><ul><li>域名解析，<a href="http://www.xxx.com转换成" target="_blank" rel="noopener">www.xxx.com转换成</a> ip，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 ip 地址</li><li>DNS 协议运行在 UDP 协议之上，使用端口号 53</li></ul></li><li><p>主机解析域名的顺序</p><ul><li>浏览器缓存</li><li>找本机的 hosts 文件</li><li>路由缓存</li><li>找 DNS 服务器(本地域名、顶级域名、根域名)<ul><li>迭代查询、递归查询</li></ul></li></ul></li></ul><h3 id="问题-2：http-基本格式"><a href="#问题-2：http-基本格式" class="headerlink" title="问题 2：http 基本格式"></a>问题 2：http 基本格式</h3><p>http 请求：</p> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/httprequest.png" class title="http 请求"> <p> http 响应：</p> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/httpresponse.png" class title="http 响应"> <h3 id="问题-3：GET、POST-区别"><a href="#问题-3：GET、POST-区别" class="headerlink" title="问题 3：GET、POST 区别"></a>问题 3：GET、POST 区别</h3> <img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/get.png" class title="GET和POST 区别"> <h3 id="问题-4：Cookies-和-Session-的区别"><a href="#问题-4：Cookies-和-Session-的区别" class="headerlink" title="问题 4：Cookies 和 Session 的区别"></a>问题 4：Cookies 和 Session 的区别</h3><ol><li><p><strong>cookie</strong> 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个 WEB 站点会话间持久的保持数据</p></li><li><p><strong>session</strong> 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其实是利用Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期了</p></li><li><p>cookie 数据保存在客户端，session 数据保存在服务器端</p></li></ol><h3 id="问题-5：一次完整的-HTTP-请求所经历的步骤"><a href="#问题-5：一次完整的-HTTP-请求所经历的步骤" class="headerlink" title="问题 5：一次完整的 HTTP 请求所经历的步骤"></a>问题 5：一次完整的 HTTP 请求所经历的步骤</h3><p> 比如：在浏览器中输入 <a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com </a>后执行的全部过程 </p><img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http.png" class title="http请求"><p>也可以参考文章：《抓包实战 | 浏览器里的HTTP 请求到底是如何完成的？》</p><p><a href="https://mp.weixin.qq.com/s/_fB7r53BGZRvpG9YAPRQ8A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_fB7r53BGZRvpG9YAPRQ8A</a></p><h3 id="问题-6：http2-0-和http1-1-的区别"><a href="#问题-6：http2-0-和http1-1-的区别" class="headerlink" title="问题 6：http2.0 和http1.1 的区别"></a>问题 6：http2.0 和http1.1 的区别</h3><img src="/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http2.png" class title="http2.0 和http1.1 的区别"> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>synchronized和lock的区别</title>
    <link href="http://yoursite.com/2020/05/16/synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/16/synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-16T14:54:12.000Z</published>
    <updated>2020-05-16T14:56:29.038Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="1-作用的位置不同"><a href="#1-作用的位置不同" class="headerlink" title="1.作用的位置不同"></a>1.作用的位置不同</h4><p>synchronized可以给方法，代码块加锁</p><p>lock只能给代码块加锁</p><h4 id="2-锁的获取锁和释放机制不同"><a href="#2-锁的获取锁和释放机制不同" class="headerlink" title="2.锁的获取锁和释放机制不同"></a>2.锁的获取锁和释放机制不同</h4><p>synchronized无需手动获取锁和释放锁，发生异常会自动解锁，不会出现死锁。</p><p>lock需要自己加锁和释放锁，如lock()和unlock()，如果忘记使用unlock()，则会出现死锁，</p><p>所以，一般我们会在finally里面使用unlock().</p><h4 id="3-lock锁的特殊要求"><a href="#3-lock锁的特殊要求" class="headerlink" title="3.lock锁的特殊要求"></a>3.lock锁的特殊要求</h4><p>//明确采用人工的方式来上锁</p><p>lock.lock();</p><p>//明确采用手工的方式来释放锁</p><p>lock.unlock();</p><h4 id="4-关于synchronized"><a href="#4-关于synchronized" class="headerlink" title="4.关于synchronized"></a>4.关于synchronized</h4><p>synchronized修饰成员方法时，默认的锁对象，就是当前对象</p><p>synchronized修饰静态方法时，默认的锁对象，当前类的class对象，比如User.class</p><p>synchronized修饰代码块时，可以自己来设置锁对象，比如</p><p>synchronized(this){</p><p>//线程进入，就自动获取到锁</p><p>//线程执行结束，自动释放锁</p><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库的三大范式</title>
    <link href="http://yoursite.com/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</id>
    <published>2020-05-16T11:55:15.000Z</published>
    <updated>2020-05-16T11:56:17.537Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1，数据库的三大范式"><a href="#1，数据库的三大范式" class="headerlink" title="1，数据库的三大范式"></a><strong>1，数据库的三大范式</strong></h2><blockquote><p>第一范式：列不可分<br>第二范式：要有主键<br>第三范式：不可存在传递依赖<br>比如商品表里面关联商品类别表，那么只需要一个关联字段product_type_id即可，其他字段信息可以通过表关联查询即可得到<br><strong>如果商品表还存在一个商品类别名称字段，如product_type_name，那就属于存在传递依赖的情况，第三范式主要是从空间的角度来考虑，避免产生冗余信息，浪费磁盘空间</strong></p></blockquote><h2 id="2，反范式设计：-第三范式"><a href="#2，反范式设计：-第三范式" class="headerlink" title="2，反范式设计：(第三范式)"></a><strong>2，反范式设计：(第三范式)</strong></h2><blockquote><p>为什么会有反范式设计？<br>原因一：提高查询效率（读多写少）<br>比如上述的描述中，显示商品信息时，经常需要伴随商品类别信息的展示，<br>所以这个时候，为了提高查询效率，可以通过冗余一个商品名称字段，这个可以将原先的表关联查询转换为单表查询</p></blockquote><blockquote><p>原因二：保存历史快照信息<br>比如订单表，里面需要包含收货人的各项信息，如姓名，电话，地址等等，这些都属于历史快照，需要冗余保存起来，<br>不能通过保存用户地址ID去关联查询，因为用户的收货人信息可能会在后期发生变更</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>对ThreadLocal的理解</title>
    <link href="http://yoursite.com/2020/05/16/%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/16/%E5%AF%B9ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-05-16T02:17:08.000Z</published>
    <updated>2020-05-18T06:59:13.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>作用：</p><p>为每一个线程创建一个副本</p><p>主要实现了在线程的上下文传递对象</p><h4 id="第一个问题：证明ThreadLocal为每个线程创建一个变量副本"><a href="#第一个问题：证明ThreadLocal为每个线程创建一个变量副本" class="headerlink" title="第一个问题：证明ThreadLocal为每个线程创建一个变量副本"></a>第一个问题：证明ThreadLocal为每个线程创建一个变量副本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Long&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;开启多个线程来执行任务</span><br><span class="line">        Task task &#x3D; new Task();</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Long result &#x3D; threadLocal.get();</span><br><span class="line">            if(result &#x3D;&#x3D; null)&#123;</span><br><span class="line">                threadLocal.set(System.currentTimeMillis());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;-&gt;&quot;+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果是不同的</p><h4 id="问题二：为什么可以给每个线程保存一个不同的副本"><a href="#问题二：为什么可以给每个线程保存一个不同的副本" class="headerlink" title="问题二：为什么可以给每个线程保存一个不同的副本"></a>问题二：为什么可以给每个线程保存一个不同的副本</h4><p>那我们来分析源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Long result = threadLocal.get();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2，获取到当前线程对应的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.以threadLocal为key，获取到entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//4.获取对应entry的value，就是我们存放到里面的变量的副本</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们需要结合set方法的源码分析，才可以更好理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取到当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2.获取当前线程对应的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//3.往map存放一个键值对</span></span><br><span class="line">            <span class="comment">//this ThreadLocal</span></span><br><span class="line">            <span class="comment">//value 保存的副本</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，我们得到结论：</p><p>每个线程都会有对应的map，map来保存键值对。</p><h4 id="问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？"><a href="#问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？" class="headerlink" title="问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？"></a>问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？</h4><p>比如：hibernate管理session，mybatis管理sqlsession，其内部都是采用ThreadLocal来实现的。</p><p>前提知识：不管是什么框架，最本质的操作都是基于JDBC，当我们需要跟数据库打交道的时候，都需要有一个connection。</p><p>那么，当我们需要在业务层实现事务控制时，该如何达到这个效果？</p><p>我们构建下代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略接口的声明</span><br><span class="line">    private UserDao userDao &#x3D; new UserDao();</span><br><span class="line">    private LogDao logDao &#x3D; new LogDao();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;事务的边界放在业务层</span><br><span class="line">    &#x2F;&#x2F;JDBC的封装，connection</span><br><span class="line">    public void add()&#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">        logDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;UserDao add。。。&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建connection对象</span><br><span class="line">        &#x2F;&#x2F;connection.commit();</span><br><span class="line">        &#x2F;&#x2F;connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LogDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;LogDao add。。。&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建connection对象</span><br><span class="line">        &#x2F;&#x2F;connection.commit();</span><br><span class="line">        &#x2F;&#x2F;connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码按上面的方式来管理connection，我们还可以保证service的事务控制吗？</p><p>这是不行的，假设第一个dao操作成功了，那么它就提交事务了，而第二个dao操作失败了，它回滚了事务，但不会影响到第一个dao的事务，因为上面这么写是两个独立的事务</p><p>那么怎么解决。</p><p>上面的根源就是两个dao操作的是不同的connection</p><p>所以，我们保证是同个connection即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;事务的边界放在业务层</span><br><span class="line">&#x2F;&#x2F;JDBC的封装，connection</span><br><span class="line">public void add()&#123;</span><br><span class="line">    Connection connection &#x3D; new Connection();</span><br><span class="line">    userDao.add(connection);</span><br><span class="line">    logDao.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方式代码不够优雅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Connection&gt; threadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line">        Connection connection &#x3D; threadLocal.get();</span><br><span class="line">        if(connection &#x3D;&#x3D; null)&#123;</span><br><span class="line">            connection &#x3D; new Connection();</span><br><span class="line">            threadLocal.set(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;UserDao add。。。&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建connection对象</span><br><span class="line">        &#x2F;&#x2F;connection.commit();</span><br><span class="line">        &#x2F;&#x2F;connection.rollback();</span><br><span class="line">        Connection connection &#x3D; ConnectionUtils.getConnection();</span><br><span class="line">        System.out.println(&quot;UserDao-&gt;&quot;+connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，我们可以保证两个dao操作的是同一个connection</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。 有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Sleep和wait的区别</title>
    <link href="http://yoursite.com/2020/05/15/Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/15/Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-15T12:49:02.000Z</published>
    <updated>2020-05-15T13:14:41.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="Sleep和wait的区别"><a href="#Sleep和wait的区别" class="headerlink" title="Sleep和wait的区别"></a>Sleep和wait的区别</h4><h5 id="1-所属的类不同"><a href="#1-所属的类不同" class="headerlink" title="1.所属的类不同"></a>1.所属的类不同</h5><p>sleep方法是定义在Thread上的</p><p>wait方法是定义在object上的</p><h5 id="2-对于锁资源的处理方式不同"><a href="#2-对于锁资源的处理方式不同" class="headerlink" title="2.对于锁资源的处理方式不同"></a>2.对于锁资源的处理方式不同</h5><p>sleep不会释放锁，也就是说，该资源还是在当前方法上，其他线程无法访问其资源</p><p>wait会释放锁，调用wait后，其他线程可访问先前被锁住的资源</p><h5 id="3-使用范围不同"><a href="#3-使用范围不同" class="headerlink" title="3.使用范围不同"></a>3.使用范围不同</h5><p>sleep可以使用在任何代码块</p><p>wait必须在同步方法或同步代码块执行</p><h5 id="4-与wait配套使用的方法"><a href="#4-与wait配套使用的方法" class="headerlink" title="4.与wait配套使用的方法"></a>4.与wait配套使用的方法</h5><ul><li>void notify()</li></ul><p>作用：唤醒在此对象监视器上等待的单个线程</p><ul><li>void notifyall()</li></ul><p>作用：唤醒在此对象监视器上等待的所有线程</p><ul><li>void wait() </li></ul><p>作用：导致当前线程等待，直到其他线程调用此对象的notify()方法或notifyall()方法</p><h5 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h5><p>(1)当线程调用wait()或者join时，线程都会进入到waiting状态，当调用notify或notifyall时，或者join的线程执行结束后，会进入runnable状态</p><p>(2)当线程调用sleep(time)，或者wait(time)时，进入time waiting状态</p><h5 id="6-为什么wait要定义在object中，而不定义在thread中？"><a href="#6-为什么wait要定义在object中，而不定义在thread中？" class="headerlink" title="6.为什么wait要定义在object中，而不定义在thread中？"></a>6.为什么wait要定义在object中，而不定义在thread中？</h5><p>因为Java的锁是对象级别的，而不是线程级别的</p><h5 id="7-为什么wait必须卸载同步代码块中"><a href="#7-为什么wait必须卸载同步代码块中" class="headerlink" title="7.为什么wait必须卸载同步代码块中"></a>7.为什么wait必须卸载同步代码块中</h5><p>原因是避免CPU切换到其他线程，而其他线程又提前执行了notify方法，那样就达不到我们的预期（先wait再由其他线程来唤醒），所以需要一个同步锁来保护</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>解决hash冲突的方法</title>
    <link href="http://yoursite.com/2020/05/15/%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/15/%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-15T07:44:48.000Z</published>
    <updated>2020-05-15T08:02:59.938Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="1-什么是哈希冲突？"><a href="#1-什么是哈希冲突？" class="headerlink" title="1.什么是哈希冲突？"></a>1.什么是哈希冲突？</h4><p>理解哈希函数</p><p>关键字和它在表中存储位置之间存在一种函数关系。这个函数我们称为为哈希函数。</p><p>hash:散列、杂凑 </p><p>​        就是把任意长度的输入，通过散列算法，变成固定长度的输出，这种是一种压缩映射.</p><pre><code>那么在这种情况下，不同的输入可能会产生相同的散列值，即这种状况下他们对应的哈希数的值是相同的，因为值相同所以不可能由散列值确定唯一的输入值，这种情况就是哈希冲突</code></pre><p>​        键(key)经过hash函数得到的结果作为地址去存放当前的键值对(key-value)(hashmap的存值方式)，但是却发现该地址已经有值了，就会产生冲突。这个冲突就是hash冲突了。</p><p>​        换句话说就是：如果两个不同对象的hashCode相同，这种现象称为hash冲突。</p><h4 id="2-解决哈希冲突"><a href="#2-解决哈希冲突" class="headerlink" title="2. 解决哈希冲突"></a>2. 解决哈希冲突</h4><p>解决哈希冲突主要有以下几种方法：</p><p><strong>开放定址法</strong></p><p><strong>再哈希法</strong></p><p><strong>链地址法</strong></p><p><strong>建立公共溢出区</strong></p><h5 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="(1)开放定址法"></a>(1)开放定址法</h5><p>这种方法的意思是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。（ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。）</p><p>线性探测再散列</p><p>当发生冲突的时候，顺序的查看下一个单元</p><p>二次(平方)探测再散列</p><p>当发生冲突的时候，在表的左右进行跳跃式探测</p><h5 id="2-再hash法"><a href="#2-再hash法" class="headerlink" title="(2)再hash法"></a>(2)再hash法</h5><p>​        这种方式是同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。</p><p>​        这种方法不易产生聚集，但增加了计算时间。</p><h5 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="(3)链地址法"></a>(3)链地址法</h5><p>​        将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><p>​        hashmap就是用此方法解决冲突的。这是Java1.7之前解决hash冲突的主要办法，但是在Java1.8之后，就对该方法进行了升级，运用红黑树的算法解决插入值相同过多的问题。</p><h5 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="(4)建立一个公共溢出区"></a>(4)建立一个公共溢出区</h5><p>​        将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><h4 id="3-HashMap-HaspTable-ConcurrentHaspMap的区别"><a href="#3-HashMap-HaspTable-ConcurrentHaspMap的区别" class="headerlink" title="3.HashMap,HaspTable,ConcurrentHaspMap的区别"></a>3.HashMap,HaspTable,ConcurrentHaspMap的区别</h4><h5 id="1-haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap"><a href="#1-haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap" class="headerlink" title="(1)haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap."></a>(1)haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap.</h5><h5 id="2-hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。"><a href="#2-hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。" class="headerlink" title="(2)hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。"></a>(2)hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。</h5><h5 id="3-concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。"><a href="#3-concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。" class="headerlink" title="(3)concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。"></a>(3)concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java子父类构造器的调用</title>
    <link href="http://yoursite.com/2020/05/13/java%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/13/java%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2020-05-13T02:15:32.000Z</published>
    <updated>2020-05-13T02:27:46.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​        在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。</p><h5 id="子父类代码执行顺序"><a href="#子父类代码执行顺序" class="headerlink" title="子父类代码执行顺序"></a>子父类代码执行顺序</h5><p>父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p><p>案例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;  System.out.println(<span class="string">"父类静态代码块"</span>);    &#125;</span><br><span class="line"></span><br><span class="line">        &#123; System.out.println(<span class="string">"父类非静态代码块"</span>);  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;  System.out.println(<span class="string">"父类构造函数"</span>);    &#125;   </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;  System.out.println(<span class="string">"子类静态代码块"</span>);    &#125;</span><br><span class="line"></span><br><span class="line">      &#123;  System.out.println(<span class="string">"子类非静态代码块"</span>);    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"子类构造函数"</span>);    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">结果为：   父类静态代码块</span><br><span class="line">           子类静态代码块</span><br><span class="line">           父类非静态代码块</span><br><span class="line">           父类构造函数</span><br><span class="line">           子类非静态代码块</span><br><span class="line">           子类构造函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线程的五大状态及其转换</title>
    <link href="http://yoursite.com/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-13T02:00:06.000Z</published>
    <updated>2020-05-13T02:19:26.209Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p> resume与suspended一起使用 </p><p>wait与notify(notifyAll)一起使用</p><p>sleep会让线程暂时不执行 </p><p>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态。    </p><p>线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。    </p><p>各线程之间的转换如下图：</p><img src="/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/p1.png" class title="线程之间的转换"><p> <strong>1.新建状态(New)：</strong> 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</p><p>   <strong>2.就绪状态(Runnable)：</strong>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。</p><p> 当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，</p><p> 并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p><p> 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU</p><p> 时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能</p><p> 同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个</p><p> 线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度</p><p> 程序(thread scheduler)来调度的。    </p><p><strong>3.运行状态(Running)：</strong>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.    </p><p><strong>4.阻塞状态(Blocked)：</strong></p><p> 线程运行过程中，可能由于各种原因进入阻塞状态: 1&gt;线程通过调用sleep方法进入睡眠状态； 2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； 3&gt;线程试图得到一个锁，而该锁正被其他线程持有； 4&gt;线程在等待某个触发条件； ……</p><p> 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间， 进入运行状态。    </p><p><strong>5.死亡状态(Dead)</strong></p><p> 有两个原因会导致线程死亡：      </p><p>（1）run方法正常退出而自然死亡，</p><p>（2）一个未捕获的异常终止了run方法而使线程猝死。</p><p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是 可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了， 则返回false.     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java创建对象的几种方式</title>
    <link href="http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-12T14:59:42.000Z</published>
    <updated>2020-05-13T01:58:49.762Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="java有5种方式来创建对象："><a href="#java有5种方式来创建对象：" class="headerlink" title="java有5种方式来创建对象："></a>java有5种方式来创建对象：</h4><p>1、使用 new 关键字（最常用）： <code>ObjectName obj = new ObjectName();</code></p><p>2、使用反射的Class类的newInstance()方法：<code>ObjectName obj = ObjectName.class.newInstance();</code></p><p>3、使用反射的Constructor类的newInstance()方法： <code>ObjectName obj = ObjectName.class.getConstructor.newInstance();</code></p><p> 4、使用对象克隆clone()方法：<code>ObjectName obj = obj.clone();</code></p><p>5、使用反序列化（ObjectInputStream）的readObject()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(FILE_NAME))) &#123; ObjectName obj = ois.readObject(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的五大基本原则</title>
    <link href="http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-05-12T14:55:21.000Z</published>
    <updated>2020-05-12T14:58:35.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h4><p><strong>单一职责原则（Single-Resposibility Principle）：</strong></p><p>一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p><p><strong>开放封闭原则（Open-Closed principle）：</strong></p><p>软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 </p><p><strong>Liskov替换原则（Liskov-Substituion Principle）：</strong></p><p>子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 </p><p><strong>依赖倒置原则（Dependecy-Inversion Principle）：</strong></p><p>依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 </p><p><strong>接口隔离原则（Interface-Segregation Principle）：</strong></p><p>使用多个小的专门的接口，而不要使用一个大的总接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有关java基本类型的默认值和取值范围</title>
    <link href="http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</id>
    <published>2020-05-12T14:40:37.000Z</published>
    <updated>2020-05-12T14:52:32.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​        </p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th><th align="center">取值范围</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">0</td><td align="center">-2^7—-2^7-1</td><td align="center">byte b=10;</td></tr><tr><td align="center">字符型</td><td align="center">\u0000</td><td align="center">0—-2^16-1</td><td align="center">char c=’c’;</td></tr><tr><td align="center">short</td><td align="center">0</td><td align="center">-2^15—-2^15-1</td><td align="center">short s=10;</td></tr><tr><td align="center">int</td><td align="center">0</td><td align="center">-2^31—-2^31-1</td><td align="center">int i=10;</td></tr><tr><td align="center">long</td><td align="center">0</td><td align="center">-2^63—-2^63-1</td><td align="center">long o=10L;</td></tr><tr><td align="center">float</td><td align="center">0.0f</td><td align="center">-2^31—-2^31-1</td><td align="center">float f=10.0F</td></tr><tr><td align="center">double</td><td align="center">0.0d</td><td align="center">-2^63—-2^63-1</td><td align="center">double d=10.0;</td></tr><tr><td align="center">boolean</td><td align="center">false</td><td align="center">true\false</td><td align="center">boolean flag=true;</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的强制类型转换</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-12T14:35:48.000Z</published>
    <updated>2020-05-12T14:39:59.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a"><a href="#经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a" class="headerlink" title="经过强制类型转换以后，变量a, b的值分别为（128 -128 ）short a = 128; byte b = (byte) a;"></a>经过强制类型转换以后，变量a, b的值分别为（128 -128 ）<code>short a = 128; byte b = (byte) a;</code></h4><p>1、Java中用补码形式表示</p><p>2、第一位正负位，1表示负，0表示正。</p><p>3、原码：一个数的二进制表示。</p><p>​         3的原码00000011  -3的 原码 10000011</p><p>4、反码：负数原码按位取反（符号位不变）。正数原码本身。</p><p>​        3的反码00000011  -3的反码11111100</p><p>5、补码：正数是原码本身。负数反码加1。</p><p>​         3的补码是00000011 -3的补码是11111101</p><p>-——————————————————————————</p><p>int占4个字节，32位</p><p>byte占1个字节，8位</p><p>所以强转时会截断。前24位</p><p>-————————————————————————–</p><p>在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：</p><p>int a = 3     00000000 00000000 00000000 00000011 （强转byte时前面24个0被截断）</p><p>byte b = 3   00000011</p><p>int a = -3    11111111 11111111  11111111  11111101 （强转byte时前面24个1被截断）</p><p>byte b = -3   11111101</p><p>-—————————————————————————</p><p>已知负数的补码，求负数：</p><p>补码-1=反码，反码按位取反=该负数绝对值</p><p>已知负数，求负数的补码：</p><p>1、负数原码除了符号位，按位取反（不含符号位），加1。</p><p>2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1</p><p>-——————————————————————————</p><p>例子：</p><p>java int 128转为byte，值：</p><p>128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的构造方法</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-12T14:12:29.000Z</published>
    <updated>2020-05-12T14:31:39.225Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。<br> 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。详见：<a href="http://blog.csdn.net/welcome000yy/article/details/8941644" target="_blank" rel="noopener">http://blog.csdn.net/welcome000yy/article/details/8941644</a><br> 接口里面的变量为常量，其实际是 public static final ；接口里面的方法为抽象方法，其实际是public abstract。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的classloader类加载器</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-05-12T13:00:57.000Z</published>
    <updated>2020-05-12T14:09:24.699Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>JDK中提供了三个ClassLoader，根据层级从高到低为：</p><p>1.Bootstrap ClassLoader，（根加载器）主要加载JVM自身工作需要的类。</p><p>2.Extension ClassLoader，（扩展类加载器）主要加载%JAVA_HOME%\lib\ext目录下的库类。</p><p>3.Application ClassLoader，（系统类加载器）主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</p><p>即使同一个名，用了不同的类加载器就判定为不同的类</p><p>JVM加载类的实现方式，我们称为 <strong>双亲委托模型</strong>：</p><p>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。</p><p><strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong></p><p>假设有一个开发者自己编写了一个名为Java<em>.lang.Object</em>的类，想借此欺骗JVM。现在他要使用<strong>自定义ClassLoader</strong>来加载自己编写的<em>java.lang.Object</em>类。然而幸运的是，<strong>双亲委托模型</strong>不会让他成功。因为JVM会优先在<strong>Bootstrap ClassLoader</strong>的路径下找到<em>java.lang.Object</em>类，并载入它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的种类以及辨析</title>
    <link href="http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/</id>
    <published>2020-05-12T12:55:32.000Z</published>
    <updated>2020-05-12T12:59:53.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。"><a href="#锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。" class="headerlink" title="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。"></a>锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。</h5><p>1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p><p>2、阻塞锁 被阻塞的线程，不会争夺锁。</p><p>3、可重入锁 多次进入改锁的域</p><p>4、读写锁</p><p>5、互斥锁 锁本身就是互斥的</p><p>6、悲观锁 不相信，这里会是安全的，必须全部上锁</p><p>7、乐观锁 相信，这里是安全的。</p><p>8、公平锁 有优先级的锁</p><p>9、非公平锁 无优先级的锁</p><p>10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p><p>11、对象锁 锁住对象</p><p>12、线程锁</p><p>13、锁粗化 多锁变成一个，自己处理</p><p>14、轻量级锁 CAS 实现</p><p>15、锁消除 偏向锁就是锁消除的一种</p><p>16、锁膨胀 jvm实现，锁粗化</p><p>17、信号量 使用阻塞锁 实现的一种策略</p><p>18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么操作会使得当前线程停止？</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/</id>
    <published>2020-05-12T12:38:45.000Z</published>
    <updated>2020-05-12T12:44:10.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A：一个InterruptedException 异常被捕获 大家都知道的嘛 （一般通过interrupt方法 中断线程） 如果抓到一个线程 都会关进catch里面 然后中断当前操作。</p><p>B：线程执行了wait()方法。  线程使用了wait方法，会强行打断当前操作，（暂停状态，不会中断线程） 进入阻塞（暂停）状态，然后需要notify方法或notifyAll方法才能进入就绪状态。</p><p>C：当前线程创建了一个新的线程。  新创建的线程不会抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。</p><p>D：一个高优先级别的线程就绪。 如C相同，你优先级别再高 也待等我现在弄完才会给你。</p><p>E：线程在MediaTracker上执行了waitforID（）调用。 </p><p>这个类是awt里面的，他的功能是加载图像，直到完成之前，该方法一直等待！这个方法是必须要抛出A选项的InterruptedException 异常的 说明这玩意会让其他线程 wait他完成！  所以会暂停当前线程~~大概是这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java的反射</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/</id>
    <published>2020-05-12T12:24:53.000Z</published>
    <updated>2020-05-12T12:37:21.860Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>反射指的是在运行时能够分析类的能力的程序。</p><p>反射机制可以用来：</p><p>1.在运行时分析类的能力–检查类的结构–所用到的就是<strong>java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的域、方法和构造器</strong>。</p><p>2.在运行时查看对象。</p><p>3.实现通用的数组操作代码。</p><p><strong>反射机制的功能：</strong></p><p>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态方法。</p><p><strong>反射机制常见作用：</strong></p><p>动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。</p><p><strong>反射机制性能问题：</strong></p><p>反射会降低效率。</p><p>void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。禁止安全检查，可以提高反射的运行速度。</p><p>可以考虑使用：cglib/javaassist操作。</p><p> Java语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象(根据安全性限制)，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。Java reflection非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。Java的这一特性非常强大，并且是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。</p><p>   但反射有两个缺点。第一个是性能问题。用于字段和方法接入时反射要远慢于直接代码。性能问题的程度取决于程序中是如何使用反射的。如果它作为程序运行中相对很少涉及的部分，缓慢的性能将不会是一个问题。即使测试中最坏情况下的计时图显示的反射操作只耗用几微秒。仅反射在性能关键的应用的核心逻辑中使用时性能问题才变得至关重要。</p><p>   许多应用中更严重的一个缺点是使用反射会模糊程序内部实际要发生的事情。程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术会带来维护问题。反射代码比相应的直接代码更复杂，正如性能比较的代码实例中看到的一样。解决这些问题的最佳方案是保守地使用反射一-仅在它可以真正增加灵活性的地方一记录其在 目标类中的使用。</p><p>   Reflection是Java程序开发语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说”自审”，并能直接操作程序的内部属性。例如，使用它能获得Java类中各成员的名称并显示出来。</p><p>   Java的这-能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一-特性。例如，Pascal. C或者C++中就没有办法在程序中获得函数定义相关的信息。</p><p>   JavaBean是reflection的实际应用之一，它能让一些工具可视化的操作软件组件。这些工具通过reflection动态的载入并取得Java组件(类)的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的关键字与保留字</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/</id>
    <published>2020-05-12T12:21:57.000Z</published>
    <updated>2020-05-12T12:24:26.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Java关键字是<a href="https://baike.baidu.com/item/电脑语言/7105622" target="_blank" rel="noopener">电脑语言</a>里事先定义的，有特别意义的标识符，有时又叫<a href="https://baike.baidu.com/item/保留字/7674788" target="_blank" rel="noopener">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><p> java中true ,false , null在java中不是关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符。</p><p>其中const和goto是java的保留字。java中所有的关键字都是小写的，还有要注意true,false,null,　friendly，sizeof不是java的关键字,但是你不能把它们作为java标识符用。</p><p>goto和const是保留字也是关键字。</p><p>关键字列表 (依字母排序 共50组)：</p><p>abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）, continue, default, do, double, else, enum, extends, final, finally, float, for, goto（保留关键字）, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while</p><p>保留字列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：</p><p>byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto （保留关键字） , const （保留关键字） , null</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于ArrayLinst与LinkList</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/</id>
    <published>2020-05-12T11:33:30.000Z</published>
    <updated>2020-05-12T11:42:07.005Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p><p>- ———————————————————————</p><p>B. 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p><p>-———————————————————————-</p><p>C. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p><p>-————————————————————————</p><p>D. ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针，所以，你懂的。</p><p>下面放一张ArrayList和LinkedList的区别表：</p><img src="/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/p1.png" class title="ArrayList和LinkedList的区别表">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于java内存区域</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-05-12T11:26:47.000Z</published>
    <updated>2020-05-12T11:31:43.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；</p><p>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中</p><p>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组</p><p>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
