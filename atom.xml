<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ned Lee&#39;s bolg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-15T13:11:45.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ned Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sleep和wait的qubie</title>
    <link href="http://yoursite.com/2020/05/15/Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/15/Sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-15T12:49:02.000Z</published>
    <updated>2020-05-15T13:11:45.218Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Sleep和wait的区别"><a href="#Sleep和wait的区别" class="headerlink" title="Sleep和wait的区别"></a>Sleep和wait的区别</h4><h5 id="1-所属的类不同"><a href="#1-所属的类不同" class="headerlink" title="1.所属的类不同"></a>1.所属的类不同</h5><p>sleep方法是定义在Thread上的</p><p>wait方法是定义在object上的</p><h5 id="2-对于锁资源的处理方式不同"><a href="#2-对于锁资源的处理方式不同" class="headerlink" title="2.对于锁资源的处理方式不同"></a>2.对于锁资源的处理方式不同</h5><p>sleep不会释放锁，也就是说，该资源还是在当前方法上，其他线程无法访问其资源</p><p>wait会释放锁，调用wait后，其他线程可访问先前被锁住的资源</p><h5 id="3-使用范围不同"><a href="#3-使用范围不同" class="headerlink" title="3.使用范围不同"></a>3.使用范围不同</h5><p>sleep可以使用在任何代码块</p><p>wait必须在同步方法或同步代码块执行</p><h5 id="4-与wait配套使用的方法"><a href="#4-与wait配套使用的方法" class="headerlink" title="4.与wait配套使用的方法"></a>4.与wait配套使用的方法</h5><ul><li>void notify()</li></ul><p>作用：唤醒在此对象监视器上等待的单个线程</p><ul><li>void notifyall()</li></ul><p>作用：唤醒在此对象监视器上等待的所有线程</p><ul><li>void wait() </li></ul><p>作用：导致当前线程等待，直到其他线程调用此对象的notify()方法或notifyall()方法</p><h5 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h5><p>(1)当线程调用wait()或者join时，线程都会进入到waiting状态，当调用notify或notifyall时，或者join的线程执行结束后，会进入runnable状态</p><p>(2)当线程调用sleep(time)，或者wait(time)时，进入time waiting状态</p><h5 id="6-为什么wait要定义在object中，而不定义在thread中？"><a href="#6-为什么wait要定义在object中，而不定义在thread中？" class="headerlink" title="6.为什么wait要定义在object中，而不定义在thread中？"></a>6.为什么wait要定义在object中，而不定义在thread中？</h5><p>因为Java的锁是对象级别的，而不是线程级别的</p><h5 id="7-为什么wait必须卸载同步代码块中"><a href="#7-为什么wait必须卸载同步代码块中" class="headerlink" title="7.为什么wait必须卸载同步代码块中"></a>7.为什么wait必须卸载同步代码块中</h5><p>原因是避免CPU切换到其他线程，而其他线程又提前执行了notify方法，那样就达不到我们的预期（先wait再由其他线程来唤醒），所以需要一个同步锁来保护</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Sleep和wait的区别&quot;&gt;&lt;a href=&quot;#Sleep和wait的区别&quot; class=&quot;headerlink&quot; title=&quot;Sleep和wait的区别&quot;&gt;&lt;/a&gt;Sleep和wait的区别&lt;/h4&gt;&lt;h5 id=&quot;1-所属的类不同&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>解决hash冲突的方法</title>
    <link href="http://yoursite.com/2020/05/15/%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/15/%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-15T07:44:48.000Z</published>
    <updated>2020-05-15T08:02:59.938Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是哈希冲突？"><a href="#1-什么是哈希冲突？" class="headerlink" title="1.什么是哈希冲突？"></a>1.什么是哈希冲突？</h4><p>理解哈希函数</p><p>关键字和它在表中存储位置之间存在一种函数关系。这个函数我们称为为哈希函数。</p><p>hash:散列、杂凑 </p><p>​        就是把任意长度的输入，通过散列算法，变成固定长度的输出，这种是一种压缩映射.</p><pre><code>那么在这种情况下，不同的输入可能会产生相同的散列值，即这种状况下他们对应的哈希数的值是相同的，因为值相同所以不可能由散列值确定唯一的输入值，这种情况就是哈希冲突</code></pre><p>​        键(key)经过hash函数得到的结果作为地址去存放当前的键值对(key-value)(hashmap的存值方式)，但是却发现该地址已经有值了，就会产生冲突。这个冲突就是hash冲突了。</p><p>​        换句话说就是：如果两个不同对象的hashCode相同，这种现象称为hash冲突。</p><h4 id="2-解决哈希冲突"><a href="#2-解决哈希冲突" class="headerlink" title="2. 解决哈希冲突"></a>2. 解决哈希冲突</h4><p>解决哈希冲突主要有以下几种方法：</p><p><strong>开放定址法</strong></p><p><strong>再哈希法</strong></p><p><strong>链地址法</strong></p><p><strong>建立公共溢出区</strong></p><h5 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="(1)开放定址法"></a>(1)开放定址法</h5><p>这种方法的意思是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。（ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。）</p><p>线性探测再散列</p><p>当发生冲突的时候，顺序的查看下一个单元</p><p>二次(平方)探测再散列</p><p>当发生冲突的时候，在表的左右进行跳跃式探测</p><h5 id="2-再hash法"><a href="#2-再hash法" class="headerlink" title="(2)再hash法"></a>(2)再hash法</h5><p>​        这种方式是同时构造多个哈希函数，当产生冲突时，计算另一个哈希函数的值。</p><p>​        这种方法不易产生聚集，但增加了计算时间。</p><h5 id="3-链地址法"><a href="#3-链地址法" class="headerlink" title="(3)链地址法"></a>(3)链地址法</h5><p>​        将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><p>​        hashmap就是用此方法解决冲突的。这是Java1.7之前解决hash冲突的主要办法，但是在Java1.8之后，就对该方法进行了升级，运用红黑树的算法解决插入值相同过多的问题。</p><h5 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="(4)建立一个公共溢出区"></a>(4)建立一个公共溢出区</h5><p>​        将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><h4 id="3-HashMap-HaspTable-ConcurrentHaspMap的区别"><a href="#3-HashMap-HaspTable-ConcurrentHaspMap的区别" class="headerlink" title="3.HashMap,HaspTable,ConcurrentHaspMap的区别"></a>3.HashMap,HaspTable,ConcurrentHaspMap的区别</h4><h5 id="1-haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap"><a href="#1-haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap" class="headerlink" title="(1)haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap."></a>(1)haspmap是线程不安全的，但是效率快，如果不是在多线程环境下，一般使用的就是hashmap.</h5><h5 id="2-hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。"><a href="#2-hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。" class="headerlink" title="(2)hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。"></a>(2)hashtable虽然是线程安全的，但是效率很低，就算是在多线程环境中，一般也不会用它。</h5><h5 id="3-concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。"><a href="#3-concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。" class="headerlink" title="(3)concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。"></a>(3)concurrenthashmap采用的是分段上锁机制，也就是将其中存储的hash表进行分段上锁，这样就在效率和安全上做到了两者兼顾。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-什么是哈希冲突？&quot;&gt;&lt;a href=&quot;#1-什么是哈希冲突？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是哈希冲突？&quot;&gt;&lt;/a&gt;1.什么是哈希冲突？&lt;/h4&gt;&lt;p&gt;理解哈希函数&lt;/p&gt;
&lt;p&gt;关键字和它在表中存储位置之间存在一种函数关系。这
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java子父类构造器的调用</title>
    <link href="http://yoursite.com/2020/05/13/java%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/13/java%E5%AD%90%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8/</id>
    <published>2020-05-13T02:15:32.000Z</published>
    <updated>2020-05-13T02:27:46.822Z</updated>
    
    <content type="html"><![CDATA[<p>​        在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。</p><h5 id="子父类代码执行顺序"><a href="#子父类代码执行顺序" class="headerlink" title="子父类代码执行顺序"></a>子父类代码执行顺序</h5><p>父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p><p>案例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;  System.out.println(<span class="string">"父类静态代码块"</span>);    &#125;</span><br><span class="line"></span><br><span class="line">        &#123; System.out.println(<span class="string">"父类非静态代码块"</span>);  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;  System.out.println(<span class="string">"父类构造函数"</span>);    &#125;   </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;  System.out.println(<span class="string">"子类静态代码块"</span>);    &#125;</span><br><span class="line"></span><br><span class="line">      &#123;  System.out.println(<span class="string">"子类非静态代码块"</span>);    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123; System.out.println(<span class="string">"子类构造函数"</span>);    &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">结果为：   父类静态代码块</span><br><span class="line">           子类静态代码块</span><br><span class="line">           父类非静态代码块</span><br><span class="line">           父类构造函数</span><br><span class="line">           子类非静态代码块</span><br><span class="line">           子类构造函数</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线程的五大状态及其转换</title>
    <link href="http://yoursite.com/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-13T02:00:06.000Z</published>
    <updated>2020-05-13T02:19:26.209Z</updated>
    
    <content type="html"><![CDATA[<p> resume与suspended一起使用 </p><p>wait与notify(notifyAll)一起使用</p><p>sleep会让线程暂时不执行 </p><p>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态。    </p><p>线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。    </p><p>各线程之间的转换如下图：</p><img src="/2020/05/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/p1.png" class title="线程之间的转换"><p> <strong>1.新建状态(New)：</strong> 当用new操作符创建一个线程时， 例如new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 当一个线程处于新生状态时，程序还没有开始运行线程中的代码</p><p>   <strong>2.就绪状态(Runnable)：</strong>一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。</p><p> 当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，</p><p> 并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。</p><p> 处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU</p><p> 时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能</p><p> 同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个</p><p> 线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度</p><p> 程序(thread scheduler)来调度的。    </p><p><strong>3.运行状态(Running)：</strong>当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法.    </p><p><strong>4.阻塞状态(Blocked)：</strong></p><p> 线程运行过程中，可能由于各种原因进入阻塞状态: 1&gt;线程通过调用sleep方法进入睡眠状态； 2&gt;线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者； 3&gt;线程试图得到一个锁，而该锁正被其他线程持有； 4&gt;线程在等待某个触发条件； ……</p><p> 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间， 进入运行状态。    </p><p><strong>5.死亡状态(Dead)</strong></p><p> 有两个原因会导致线程死亡：      </p><p>（1）run方法正常退出而自然死亡，</p><p>（2）一个未捕获的异常终止了run方法而使线程猝死。</p><p>为了确定线程在当前是否存活着（就是要么是可运行的，要么是被阻塞了），需要使用isAlive方法。如果是 可运行或被阻塞，这个方法返回true； 如果线程仍旧是new状态且不是可运行的， 或者线程死亡了， 则返回false.     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; resume与suspended一起使用 &lt;/p&gt;
&lt;p&gt;wait与notify(notifyAll)一起使用&lt;/p&gt;
&lt;p&gt;sleep会让线程暂时不执行 &lt;/p&gt;
&lt;p&gt;suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java创建对象的几种方式</title>
    <link href="http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-12T14:59:42.000Z</published>
    <updated>2020-05-13T01:58:49.762Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java有5种方式来创建对象："><a href="#java有5种方式来创建对象：" class="headerlink" title="java有5种方式来创建对象："></a>java有5种方式来创建对象：</h4><p>1、使用 new 关键字（最常用）： <code>ObjectName obj = new ObjectName();</code></p><p>2、使用反射的Class类的newInstance()方法：<code>ObjectName obj = ObjectName.class.newInstance();</code></p><p>3、使用反射的Constructor类的newInstance()方法： <code>ObjectName obj = ObjectName.class.getConstructor.newInstance();</code></p><p> 4、使用对象克隆clone()方法：<code>ObjectName obj = obj.clone();</code></p><p>5、使用反序列化（ObjectInputStream）的readObject()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(FILE_NAME))) &#123; ObjectName obj = ois.readObject(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;java有5种方式来创建对象：&quot;&gt;&lt;a href=&quot;#java有5种方式来创建对象：&quot; class=&quot;headerlink&quot; title=&quot;java有5种方式来创建对象：&quot;&gt;&lt;/a&gt;java有5种方式来创建对象：&lt;/h4&gt;&lt;p&gt;1、使用 new 关键字（最常用）：
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的五大基本原则</title>
    <link href="http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-05-12T14:55:21.000Z</published>
    <updated>2020-05-12T14:58:35.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h4><p><strong>单一职责原则（Single-Resposibility Principle）：</strong></p><p>一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p><p><strong>开放封闭原则（Open-Closed principle）：</strong></p><p>软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 </p><p><strong>Liskov替换原则（Liskov-Substituion Principle）：</strong></p><p>子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 </p><p><strong>依赖倒置原则（Dependecy-Inversion Principle）：</strong></p><p>依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 </p><p><strong>接口隔离原则（Interface-Segregation Principle）：</strong></p><p>使用多个小的专门的接口，而不要使用一个大的总接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面向对象的五大基本原则&quot;&gt;&lt;a href=&quot;#面向对象的五大基本原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象的五大基本原则&quot;&gt;&lt;/a&gt;面向对象的五大基本原则&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;单一职责原则（Single-Resposibilit
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有关java基本类型的默认值和取值范围</title>
    <link href="http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</id>
    <published>2020-05-12T14:40:37.000Z</published>
    <updated>2020-05-12T14:52:32.332Z</updated>
    
    <content type="html"><![CDATA[<p>​        </p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th><th align="center">取值范围</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">0</td><td align="center">-2^7—-2^7-1</td><td align="center">byte b=10;</td></tr><tr><td align="center">字符型</td><td align="center">\u0000</td><td align="center">0—-2^16-1</td><td align="center">char c=’c’;</td></tr><tr><td align="center">short</td><td align="center">0</td><td align="center">-2^15—-2^15-1</td><td align="center">short s=10;</td></tr><tr><td align="center">int</td><td align="center">0</td><td align="center">-2^31—-2^31-1</td><td align="center">int i=10;</td></tr><tr><td align="center">long</td><td align="center">0</td><td align="center">-2^63—-2^63-1</td><td align="center">long o=10L;</td></tr><tr><td align="center">float</td><td align="center">0.0f</td><td align="center">-2^31—-2^31-1</td><td align="center">float f=10.0F</td></tr><tr><td align="center">double</td><td align="center">0.0d</td><td align="center">-2^63—-2^63-1</td><td align="center">double d=10.0;</td></tr><tr><td align="center">boolean</td><td align="center">false</td><td align="center">true\false</td><td align="center">boolean flag=true;</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;类型&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;默认值&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;取值范围&lt;/th&gt;
&lt;th align=&quot;center&quot;
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的强制类型转换</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-12T14:35:48.000Z</published>
    <updated>2020-05-12T14:39:59.170Z</updated>
    
    <content type="html"><![CDATA[<h4 id="经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a"><a href="#经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a" class="headerlink" title="经过强制类型转换以后，变量a, b的值分别为（128 -128 ）short a = 128; byte b = (byte) a;"></a>经过强制类型转换以后，变量a, b的值分别为（128 -128 ）<code>short a = 128; byte b = (byte) a;</code></h4><p>1、Java中用补码形式表示</p><p>2、第一位正负位，1表示负，0表示正。</p><p>3、原码：一个数的二进制表示。</p><p>​         3的原码00000011  -3的 原码 10000011</p><p>4、反码：负数原码按位取反（符号位不变）。正数原码本身。</p><p>​        3的反码00000011  -3的反码11111100</p><p>5、补码：正数是原码本身。负数反码加1。</p><p>​         3的补码是00000011 -3的补码是11111101</p><p>-——————————————————————————</p><p>int占4个字节，32位</p><p>byte占1个字节，8位</p><p>所以强转时会截断。前24位</p><p>-————————————————————————–</p><p>在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：</p><p>int a = 3     00000000 00000000 00000000 00000011 （强转byte时前面24个0被截断）</p><p>byte b = 3   00000011</p><p>int a = -3    11111111 11111111  11111111  11111101 （强转byte时前面24个1被截断）</p><p>byte b = -3   11111101</p><p>-—————————————————————————</p><p>已知负数的补码，求负数：</p><p>补码-1=反码，反码按位取反=该负数绝对值</p><p>已知负数，求负数的补码：</p><p>1、负数原码除了符号位，按位取反（不含符号位），加1。</p><p>2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1</p><p>-——————————————————————————</p><p>例子：</p><p>java int 128转为byte，值：</p><p>128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a&quot;&gt;&lt;a href=&quot;#经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a&quot; class=
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的构造方法</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-12T14:12:29.000Z</published>
    <updated>2020-05-12T14:31:39.225Z</updated>
    
    <content type="html"><![CDATA[<p>构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。<br> 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。详见：<a href="http://blog.csdn.net/welcome000yy/article/details/8941644" target="_blank" rel="noopener">http://blog.csdn.net/welcome000yy/article/details/8941644</a><br> 接口里面的变量为常量，其实际是 public static final ；接口里面的方法为抽象方法，其实际是public abstract。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。&lt;br&gt; 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 sync
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的classloader类加载器</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-05-12T13:00:57.000Z</published>
    <updated>2020-05-12T14:09:24.699Z</updated>
    
    <content type="html"><![CDATA[<p>JDK中提供了三个ClassLoader，根据层级从高到低为：</p><p>1.Bootstrap ClassLoader，（根加载器）主要加载JVM自身工作需要的类。</p><p>2.Extension ClassLoader，（扩展类加载器）主要加载%JAVA_HOME%\lib\ext目录下的库类。</p><p>3.Application ClassLoader，（系统类加载器）主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</p><p>即使同一个名，用了不同的类加载器就判定为不同的类</p><p>JVM加载类的实现方式，我们称为 <strong>双亲委托模型</strong>：</p><p>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。</p><p><strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong></p><p>假设有一个开发者自己编写了一个名为Java<em>.lang.Object</em>的类，想借此欺骗JVM。现在他要使用<strong>自定义ClassLoader</strong>来加载自己编写的<em>java.lang.Object</em>类。然而幸运的是，<strong>双亲委托模型</strong>不会让他成功。因为JVM会优先在<strong>Bootstrap ClassLoader</strong>的路径下找到<em>java.lang.Object</em>类，并载入它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDK中提供了三个ClassLoader，根据层级从高到低为：&lt;/p&gt;
&lt;p&gt;1.Bootstrap ClassLoader，（根加载器）主要加载JVM自身工作需要的类。&lt;/p&gt;
&lt;p&gt;2.Extension ClassLoader，（扩展类加载器）主要加载%JAVA_HO
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的种类以及辨析</title>
    <link href="http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/</id>
    <published>2020-05-12T12:55:32.000Z</published>
    <updated>2020-05-12T12:59:53.160Z</updated>
    
    <content type="html"><![CDATA[<h5 id="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。"><a href="#锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。" class="headerlink" title="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。"></a>锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。</h5><p>1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p><p>2、阻塞锁 被阻塞的线程，不会争夺锁。</p><p>3、可重入锁 多次进入改锁的域</p><p>4、读写锁</p><p>5、互斥锁 锁本身就是互斥的</p><p>6、悲观锁 不相信，这里会是安全的，必须全部上锁</p><p>7、乐观锁 相信，这里是安全的。</p><p>8、公平锁 有优先级的锁</p><p>9、非公平锁 无优先级的锁</p><p>10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p><p>11、对象锁 锁住对象</p><p>12、线程锁</p><p>13、锁粗化 多锁变成一个，自己处理</p><p>14、轻量级锁 CAS 实现</p><p>15、锁消除 偏向锁就是锁消除的一种</p><p>16、锁膨胀 jvm实现，锁粗化</p><p>17、信号量 使用阻塞锁 实现的一种策略</p><p>18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。&quot;&gt;&lt;a href=&quot;#锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么操作会使得当前线程停止？</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/</id>
    <published>2020-05-12T12:38:45.000Z</published>
    <updated>2020-05-12T12:44:10.341Z</updated>
    
    <content type="html"><![CDATA[<p>A：一个InterruptedException 异常被捕获 大家都知道的嘛 （一般通过interrupt方法 中断线程） 如果抓到一个线程 都会关进catch里面 然后中断当前操作。</p><p>B：线程执行了wait()方法。  线程使用了wait方法，会强行打断当前操作，（暂停状态，不会中断线程） 进入阻塞（暂停）状态，然后需要notify方法或notifyAll方法才能进入就绪状态。</p><p>C：当前线程创建了一个新的线程。  新创建的线程不会抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。</p><p>D：一个高优先级别的线程就绪。 如C相同，你优先级别再高 也待等我现在弄完才会给你。</p><p>E：线程在MediaTracker上执行了waitforID（）调用。 </p><p>这个类是awt里面的，他的功能是加载图像，直到完成之前，该方法一直等待！这个方法是必须要抛出A选项的InterruptedException 异常的 说明这玩意会让其他线程 wait他完成！  所以会暂停当前线程~~大概是这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A：一个InterruptedException 异常被捕获 大家都知道的嘛 （一般通过interrupt方法 中断线程） 如果抓到一个线程 都会关进catch里面 然后中断当前操作。&lt;/p&gt;
&lt;p&gt;B：线程执行了wait()方法。  线程使用了wait方法，会强行打断当前
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java的反射</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/</id>
    <published>2020-05-12T12:24:53.000Z</published>
    <updated>2020-05-12T12:37:21.860Z</updated>
    
    <content type="html"><![CDATA[<p>反射指的是在运行时能够分析类的能力的程序。</p><p>反射机制可以用来：</p><p>1.在运行时分析类的能力–检查类的结构–所用到的就是<strong>java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的域、方法和构造器</strong>。</p><p>2.在运行时查看对象。</p><p>3.实现通用的数组操作代码。</p><p><strong>反射机制的功能：</strong></p><p>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态方法。</p><p><strong>反射机制常见作用：</strong></p><p>动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。</p><p><strong>反射机制性能问题：</strong></p><p>反射会降低效率。</p><p>void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。禁止安全检查，可以提高反射的运行速度。</p><p>可以考虑使用：cglib/javaassist操作。</p><p> Java语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象(根据安全性限制)，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。Java reflection非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。Java的这一特性非常强大，并且是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。</p><p>   但反射有两个缺点。第一个是性能问题。用于字段和方法接入时反射要远慢于直接代码。性能问题的程度取决于程序中是如何使用反射的。如果它作为程序运行中相对很少涉及的部分，缓慢的性能将不会是一个问题。即使测试中最坏情况下的计时图显示的反射操作只耗用几微秒。仅反射在性能关键的应用的核心逻辑中使用时性能问题才变得至关重要。</p><p>   许多应用中更严重的一个缺点是使用反射会模糊程序内部实际要发生的事情。程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术会带来维护问题。反射代码比相应的直接代码更复杂，正如性能比较的代码实例中看到的一样。解决这些问题的最佳方案是保守地使用反射一-仅在它可以真正增加灵活性的地方一记录其在 目标类中的使用。</p><p>   Reflection是Java程序开发语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说”自审”，并能直接操作程序的内部属性。例如，使用它能获得Java类中各成员的名称并显示出来。</p><p>   Java的这-能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一-特性。例如，Pascal. C或者C++中就没有办法在程序中获得函数定义相关的信息。</p><p>   JavaBean是reflection的实际应用之一，它能让一些工具可视化的操作软件组件。这些工具通过reflection动态的载入并取得Java组件(类)的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射指的是在运行时能够分析类的能力的程序。&lt;/p&gt;
&lt;p&gt;反射机制可以用来：&lt;/p&gt;
&lt;p&gt;1.在运行时分析类的能力–检查类的结构–所用到的就是&lt;strong&gt;java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的域、方法
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的关键字与保留字</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/</id>
    <published>2020-05-12T12:21:57.000Z</published>
    <updated>2020-05-12T12:24:26.372Z</updated>
    
    <content type="html"><![CDATA[<p>Java关键字是<a href="https://baike.baidu.com/item/电脑语言/7105622" target="_blank" rel="noopener">电脑语言</a>里事先定义的，有特别意义的标识符，有时又叫<a href="https://baike.baidu.com/item/保留字/7674788" target="_blank" rel="noopener">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><p> java中true ,false , null在java中不是关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符。</p><p>其中const和goto是java的保留字。java中所有的关键字都是小写的，还有要注意true,false,null,　friendly，sizeof不是java的关键字,但是你不能把它们作为java标识符用。</p><p>goto和const是保留字也是关键字。</p><p>关键字列表 (依字母排序 共50组)：</p><p>abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）, continue, default, do, double, else, enum, extends, final, finally, float, for, goto（保留关键字）, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while</p><p>保留字列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：</p><p>byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto （保留关键字） , const （保留关键字） , null</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java关键字是&lt;a href=&quot;https://baike.baidu.com/item/电脑语言/7105622&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电脑语言&lt;/a&gt;里事先定义的，有特别意义的标识符，有时又叫&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于ArrayLinst与LinkList</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/</id>
    <published>2020-05-12T11:33:30.000Z</published>
    <updated>2020-05-12T11:42:07.005Z</updated>
    
    <content type="html"><![CDATA[<p>A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p><p>- ———————————————————————</p><p>B. 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p><p>-———————————————————————-</p><p>C. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p><p>-————————————————————————</p><p>D. ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针，所以，你懂的。</p><p>下面放一张ArrayList和LinkedList的区别表：</p><img src="/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/p1.png" class title="ArrayList和LinkedList的区别表">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于java内存区域</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-05-12T11:26:47.000Z</published>
    <updated>2020-05-12T11:31:43.382Z</updated>
    
    <content type="html"><![CDATA[<p>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；</p><p>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中</p><p>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组</p><p>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>二叉树查找的时间复杂度</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2020-05-12T11:22:50.000Z</published>
    <updated>2020-05-12T11:25:39.246Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树查找的时间复杂度"><a href="#二叉树查找的时间复杂度" class="headerlink" title="二叉树查找的时间复杂度"></a>二叉树查找的时间复杂度</h4><p>​        给定值的比较次数等于给定值节点在二叉排序树中的层数。如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;二叉树查找的时间复杂度&quot;&gt;&lt;a href=&quot;#二叉树查找的时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;二叉树查找的时间复杂度&quot;&gt;&lt;/a&gt;二叉树查找的时间复杂度&lt;/h4&gt;&lt;p&gt;​        给定值的比较次数等于给定值节点在二叉排序树中的层数
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>堆与栈的概念和区别</title>
    <link href="http://yoursite.com/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-12T07:08:42.000Z</published>
    <updated>2020-05-13T02:14:02.656Z</updated>
    
    <content type="html"><![CDATA[<p>​        Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p><p>   JVM内存的划分有五片：</p><p>​    1.  寄存器；</p><p>​    2.  本地方法区；</p><p>​    3.  方法区；</p><p>​    4.  栈内存；</p><p>​    5.  堆内存</p><img src="/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/heapandstack.png" class title="堆与栈"><p> 我们重点来说一下堆和栈：</p><p>​        栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p><pre><code>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</code></pre><p>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</p><p><strong>·    栈区:</strong></p><ol><li><p>每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中</p></li><li><p>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</p></li><li><p>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p></li></ol><p><strong>·    堆区:</strong></p><ol><li>存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。</li><li>jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配</li></ol><p>Java 的垃圾回收器（GC）主要针对堆区</p><p><strong>·    方法区:</strong></p><ol><li><p>又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><img src="/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/p2.png" class title="java内存区域"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。&lt;/p
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池的作用</title>
    <link href="http://yoursite.com/2020/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-05-12T07:01:06.000Z</published>
    <updated>2020-05-12T07:07:52.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据库连接池的作用"><a href="#数据库连接池的作用" class="headerlink" title="数据库连接池的作用"></a>数据库连接池的作用</h4><p>​        对于一个简单的数据库引用，用于对数据库的访问不是很频繁。这时就可以简单的在需要访问数据库是，就创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库引用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。</p><p>　　对于共享资源，有一个很著名的设计模式：资源池。该模式正是为了解决资源频繁分配、释放所造成的问题的。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略，最终目标是实现连接的高效、安全的复用。 </p><p>　　数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。如：外部使用者可通过getConnection 方法获取连接，使用完毕后再通过releaseConnection 方法将连接返回，注意此时连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备。</p><p>数据库连接池技术带来的优势：</p><p><strong>1.限定了数据库连接的个数，不会由于数据库连接过多，导致系统运行缓慢或者崩溃</strong></p><p><strong>2.不需要每次去创建或销毁，节约资源</strong></p><p><strong>3.不需要每次都去创建，相应时间更快</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据库连接池的作用&quot;&gt;&lt;a href=&quot;#数据库连接池的作用&quot; class=&quot;headerlink&quot; title=&quot;数据库连接池的作用&quot;&gt;&lt;/a&gt;数据库连接池的作用&lt;/h4&gt;&lt;p&gt;​        对于一个简单的数据库引用，用于对数据库的访问不是很频繁。这时就可以
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>创建多线程的4种方式</title>
    <link href="http://yoursite.com/2020/05/11/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/11/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-11T12:38:14.000Z</published>
    <updated>2020-05-11T14:13:30.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java中创建多线程的4种方式"><a href="#java中创建多线程的4种方式" class="headerlink" title="java中创建多线程的4种方式"></a>java中创建多线程的4种方式</h4><h5 id="1-线程是什么？"><a href="#1-线程是什么？" class="headerlink" title="1.线程是什么？"></a>1.线程是什么？</h5><p>​    线程被称为轻量级进程，是程序执行的最小单位，它是指在程序执行过程中，能够执行代码的一个执行单位。每个程序都至少有一个线程，也即是程序本身。</p><h5 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2.线程状态"></a>2.线程状态</h5><p>​    Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中一个状态。，这5种状态如下：</p><p>（1）新建（New）：创建后尚未启动的线程处于这种状态</p><p>（2）运行（Runable）：Runable包括了操作系统线程状态的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</p><p>（3）等待（Wating）：处于这种状态的线程不会被分配CPU执行时间。等待状态又分为无限期等待和有限期等待，处于无限期等待的线程需要被其他线程显示地唤醒，没有设置Timeout参数的Object.wait()、没有设置Timeout参数的Thread.join()方法都会使线程进入无限期等待状态；有限期等待状态无须等待被其他线程显示地唤醒，在一定时间之后它们会由系统自动唤醒，Thread.sleep()、设置了Timeout参数的Object.wait()、设置了Timeout参数的Thread.join()方法都会使线程进入有限期等待状态。</p><p>（4）阻塞（Blocked）：线程被阻塞了，“阻塞状态”与”等待状态“的区别是：”阻塞状态“在等待着获取到一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而”等待状态“则是在等待一段时间或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p><p>（5）结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p><h5 id="3-java创建多线程的四种方式"><a href="#3-java创建多线程的四种方式" class="headerlink" title="3.java创建多线程的四种方式"></a>3.java创建多线程的四种方式</h5><p>（1）   继承Thread类创建线程</p><p>（2）   实现Runnable接口创建线程</p><p>（3）   使用Callable和FutureTask创建线程</p><p>（4）   使用线程池，例如用Executor框架创建线程</p><p><strong>1)继承Thread类创建线程步骤如下：</strong></p><p>定义一个继承Thread线程类的类，在类中重写run方法。</p><p>在main函数中实例化这个类，初始化实现继承Thread类的对象。</p><p>用这个类的实例调用start方法，执行覆写的run方法。这里是父类即Thread接收创建的对象，由于自身没有start方法，所以是调用父类Thread的start方法创建线程。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2)实现Runnable接口创建线程步骤如下：</strong></p><p>定义一个实现Runnable接口的类A，在类中重写run方法。</p><p>在main函数中实例化这个类，但是注意，这不是线程类或者其子类，无法使用start方法，所以无法像1)方法一样用父类接收其对象直接调用start方法执行run方法。</p><p>实例化线程类，将上一步实例化的Runnable接口的类作为参数传给Thread线程类，初始化线程对象，即 Thread t = new Thread(new A());</p><p>线程类实例调用start方法执行run方法体。</p><p>为什么不直接调用run方法，而是必须先调用start方法呢？</p><p>因为start方法会启动线程，此时该线程处于就绪状态，start方法体中有一个start0的native方法，在这个方法里创建了线程，并且执行调用了重写的run方法，在run方法结束时，线程便会中止，也就是start0方法退出时。如果是直接调用run方法，即调用重写的run方法，这和普通方法没有什么区别，不会创建新线程，因为创建新线程，使线程处于就绪状态的操作在start方法中，而run方法会被jvm在start方法中的start0中调用。</p><p> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start0方法源码解析请看<a href="https://www.jianshu.com/p/81a56497e073" target="_blank" rel="noopener">https://www.jianshu.com/p/81a56497e073</a></p><p>一个线程可以多次调用start方法吗?</p><p>不能，会抛出下列异常，也就是非法线程状态异常，属于运行异常。查看源码可以看到在执行start时，会对线程状态进行判断，如果线程已经启动过，那么通常情况下无法再次进行启动，这一点在源码注释中也可以看到。即在同一个线程只能start一次，多次调用start方法会抛出异常。当调用start方法时，线程会被添加到线程组中，等待线程调度器调用，当获取到资源时，就进入运行状态。</p><p>源码分析请看<a href="https://cloud.tencent.com/developer/article/1386458" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1386458</a></p><p><strong>3)使用Callable和FutureTask创建线程步骤如下：</strong></p><p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大。</p><blockquote><p><strong>call()方法可以有返回值</strong></p></blockquote><blockquote><p><strong>call()方法可以声明抛出异常</strong></p></blockquote><p>Java5之后提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p><blockquote><p>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p></blockquote><blockquote><p>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p></blockquote><blockquote><p>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p></blockquote><blockquote><p>boolean isDone()：若Callable任务完成，返回True</p></blockquote><blockquote><p>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p></blockquote><p>介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下：</p><p><font color="#006666"> 1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</font><br></p><p><font color="#006666">2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</font><br></p><p><font color="#006666">3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</font><br></p><p><font color="#006666">4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</font><br></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</span><br><span class="line"></span><br><span class="line">　　　<span class="comment">//使用Lambda表达式创建Callable对象</span></span><br><span class="line"></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line"></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line"></span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> Thread(task,<span class="string">"有返回值的线程"</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　System.out.println(<span class="string">"子线程的返回值："</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line"></span><br><span class="line">　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前三种方式比较：</strong></p><p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p><p>1、线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p><p>2、这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p><p>3、但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p><p>4、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p><p>注：一般推荐采用实现接口的方式来创建多线程</p><p><strong>4)使用线程池，例如用Executor框架步骤如下：</strong></p><p>使用Executors工具类中的静态工厂方法用于创建线程池。</p><p>创建线程池使用execute方法启动线程。</p><p>使用shutdown方法等待提交的任务执行完成并后关闭线程。</p><p>Runnable和Callable有什么区别？</p><p>Runnable接口定义的run方法，Callable定义的是call方法。</p><p>run方法没有返回值，call方法必须有返回值。</p><p>run方法无法抛出异常，call方法可以抛出checked exception。</p><p>Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.</p><p>几种方法优缺点对比：<a href="https://blog.csdn.net/sinat_27933301/article/details/69944286" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27933301/article/details/69944286</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;java中创建多线程的4种方式&quot;&gt;&lt;a href=&quot;#java中创建多线程的4种方式&quot; class=&quot;headerlink&quot; title=&quot;java中创建多线程的4种方式&quot;&gt;&lt;/a&gt;java中创建多线程的4种方式&lt;/h4&gt;&lt;h5 id=&quot;1-线程是什么？&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
