<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ned Lee&#39;s bolg</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-12T15:02:48.381Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ned Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java创建对象的几种方式</title>
    <link href="http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/12/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-12T14:59:42.000Z</published>
    <updated>2020-05-12T15:02:48.381Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java有5种方式来创建对象："><a href="#java有5种方式来创建对象：" class="headerlink" title="java有5种方式来创建对象："></a>java有5种方式来创建对象：</h4><p>1、使用 new 关键字（最常用）： <code>ObjectName obj = new ObjectName();</code></p><p>2、使用反射的Class类的newInstance()方法：<code>ObjectName obj = ObjectName.class.newInstance();</code></p><p>3、使用反射的Constructor类的newInstance()方法： <code>ObjectName obj = ObjectName.class.getConstructor.newInstance();</code></p><p> 4、使用对象克隆clone()方法：<code>ObjectName obj = obj.clone();</code></p><p>5、使用反序列化（ObjectInputStream）的readObject()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(FILE_NAME))) &#123; ObjectName obj = ois.readObject(); &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;java有5种方式来创建对象：&quot;&gt;&lt;a href=&quot;#java有5种方式来创建对象：&quot; class=&quot;headerlink&quot; title=&quot;java有5种方式来创建对象：&quot;&gt;&lt;/a&gt;java有5种方式来创建对象：&lt;/h4&gt;&lt;p&gt;1、使用 new 关键字（最常用）：
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的五大基本原则</title>
    <link href="http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/05/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-05-12T14:55:21.000Z</published>
    <updated>2020-05-12T14:58:35.647Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h4><p><strong>单一职责原则（Single-Resposibility Principle）：</strong></p><p>一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p><p><strong>开放封闭原则（Open-Closed principle）：</strong></p><p>软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 </p><p><strong>Liskov替换原则（Liskov-Substituion Principle）：</strong></p><p>子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 </p><p><strong>依赖倒置原则（Dependecy-Inversion Principle）：</strong></p><p>依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 </p><p><strong>接口隔离原则（Interface-Segregation Principle）：</strong></p><p>使用多个小的专门的接口，而不要使用一个大的总接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面向对象的五大基本原则&quot;&gt;&lt;a href=&quot;#面向对象的五大基本原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象的五大基本原则&quot;&gt;&lt;/a&gt;面向对象的五大基本原则&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;单一职责原则（Single-Resposibilit
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>有关java基本类型的默认值和取值范围</title>
    <link href="http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"/>
    <id>http://yoursite.com/2020/05/12/%E6%9C%89%E5%85%B3java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/</id>
    <published>2020-05-12T14:40:37.000Z</published>
    <updated>2020-05-12T14:52:32.332Z</updated>
    
    <content type="html"><![CDATA[<p>​        </p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th><th align="center">取值范围</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">0</td><td align="center">-2^7—-2^7-1</td><td align="center">byte b=10;</td></tr><tr><td align="center">字符型</td><td align="center">\u0000</td><td align="center">0—-2^16-1</td><td align="center">char c=’c’;</td></tr><tr><td align="center">short</td><td align="center">0</td><td align="center">-2^15—-2^15-1</td><td align="center">short s=10;</td></tr><tr><td align="center">int</td><td align="center">0</td><td align="center">-2^31—-2^31-1</td><td align="center">int i=10;</td></tr><tr><td align="center">long</td><td align="center">0</td><td align="center">-2^63—-2^63-1</td><td align="center">long o=10L;</td></tr><tr><td align="center">float</td><td align="center">0.0f</td><td align="center">-2^31—-2^31-1</td><td align="center">float f=10.0F</td></tr><tr><td align="center">double</td><td align="center">0.0d</td><td align="center">-2^63—-2^63-1</td><td align="center">double d=10.0;</td></tr><tr><td align="center">boolean</td><td align="center">false</td><td align="center">true\false</td><td align="center">boolean flag=true;</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;类型&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;默认值&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;取值范围&lt;/th&gt;
&lt;th align=&quot;center&quot;
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的强制类型转换</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-12T14:35:48.000Z</published>
    <updated>2020-05-12T14:39:59.170Z</updated>
    
    <content type="html"><![CDATA[<h4 id="经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a"><a href="#经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a" class="headerlink" title="经过强制类型转换以后，变量a, b的值分别为（128 -128 ）short a = 128; byte b = (byte) a;"></a>经过强制类型转换以后，变量a, b的值分别为（128 -128 ）<code>short a = 128; byte b = (byte) a;</code></h4><p>1、Java中用补码形式表示</p><p>2、第一位正负位，1表示负，0表示正。</p><p>3、原码：一个数的二进制表示。</p><p>​         3的原码00000011  -3的 原码 10000011</p><p>4、反码：负数原码按位取反（符号位不变）。正数原码本身。</p><p>​        3的反码00000011  -3的反码11111100</p><p>5、补码：正数是原码本身。负数反码加1。</p><p>​         3的补码是00000011 -3的补码是11111101</p><p>-——————————————————————————</p><p>int占4个字节，32位</p><p>byte占1个字节，8位</p><p>所以强转时会截断。前24位</p><p>-————————————————————————–</p><p>在内存中表示形式（ 注意java中是以补码表示一个数，所以表示形式是补码，不是原码！ ）：</p><p>int a = 3     00000000 00000000 00000000 00000011 （强转byte时前面24个0被截断）</p><p>byte b = 3   00000011</p><p>int a = -3    11111111 11111111  11111111  11111101 （强转byte时前面24个1被截断）</p><p>byte b = -3   11111101</p><p>-—————————————————————————</p><p>已知负数的补码，求负数：</p><p>补码-1=反码，反码按位取反=该负数绝对值</p><p>已知负数，求负数的补码：</p><p>1、负数原码除了符号位，按位取反（不含符号位），加1。</p><p>2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1</p><p>-——————————————————————————</p><p>例子：</p><p>java int 128转为byte，值：</p><p>128为正数，补码为10000000（前面24个0省略），变成byte，只剩下10000000（byte为1个字节），因为开头是1，所以为负数。即1个负数的补码是10000000。反码是01111111，原码是1000000。是128.因为是负数，所以是-128。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a&quot;&gt;&lt;a href=&quot;#经过强制类型转换以后，变量a-b的值分别为（128-128-）short-a-128-byte-b-byte-a&quot; class=
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的构造方法</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-12T14:12:29.000Z</published>
    <updated>2020-05-12T14:31:39.225Z</updated>
    
    <content type="html"><![CDATA[<p>构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。<br> 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。详见：<a href="http://blog.csdn.net/welcome000yy/article/details/8941644" target="_blank" rel="noopener">http://blog.csdn.net/welcome000yy/article/details/8941644</a><br> 接口里面的变量为常量，其实际是 public static final ；接口里面的方法为抽象方法，其实际是public abstract。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;构造方法每次都是构造出新的对象，不存在多个线程同时读写同一对象中的属性的问题，所以不需要同步 。&lt;br&gt; 如果父类中的某个方法使用了 synchronized关键字，而子类中也覆盖了这个方法，默认情况下子类中的这个方法并不是同步的，必须显示的在子类的这个方法中加上 sync
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java中的classloader类加载器</title>
    <link href="http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2020/05/12/java%E4%B8%AD%E7%9A%84classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-05-12T13:00:57.000Z</published>
    <updated>2020-05-12T14:09:24.699Z</updated>
    
    <content type="html"><![CDATA[<p>JDK中提供了三个ClassLoader，根据层级从高到低为：</p><p>1.Bootstrap ClassLoader，（根加载器）主要加载JVM自身工作需要的类。</p><p>2.Extension ClassLoader，（扩展类加载器）主要加载%JAVA_HOME%\lib\ext目录下的库类。</p><p>3.Application ClassLoader，（系统类加载器）主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</p><p>即使同一个名，用了不同的类加载器就判定为不同的类</p><p>JVM加载类的实现方式，我们称为 <strong>双亲委托模型</strong>：</p><p>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。</p><p><strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong></p><p>假设有一个开发者自己编写了一个名为Java<em>.lang.Object</em>的类，想借此欺骗JVM。现在他要使用<strong>自定义ClassLoader</strong>来加载自己编写的<em>java.lang.Object</em>类。然而幸运的是，<strong>双亲委托模型</strong>不会让他成功。因为JVM会优先在<strong>Bootstrap ClassLoader</strong>的路径下找到<em>java.lang.Object</em>类，并载入它</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JDK中提供了三个ClassLoader，根据层级从高到低为：&lt;/p&gt;
&lt;p&gt;1.Bootstrap ClassLoader，（根加载器）主要加载JVM自身工作需要的类。&lt;/p&gt;
&lt;p&gt;2.Extension ClassLoader，（扩展类加载器）主要加载%JAVA_HO
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java锁的种类以及辨析</title>
    <link href="http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/Java%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%E4%BB%A5%E5%8F%8A%E8%BE%A8%E6%9E%90/</id>
    <published>2020-05-12T12:55:32.000Z</published>
    <updated>2020-05-12T12:59:53.160Z</updated>
    
    <content type="html"><![CDATA[<h5 id="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。"><a href="#锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。" class="headerlink" title="锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。"></a>锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利。</h5><p>1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p><p>2、阻塞锁 被阻塞的线程，不会争夺锁。</p><p>3、可重入锁 多次进入改锁的域</p><p>4、读写锁</p><p>5、互斥锁 锁本身就是互斥的</p><p>6、悲观锁 不相信，这里会是安全的，必须全部上锁</p><p>7、乐观锁 相信，这里是安全的。</p><p>8、公平锁 有优先级的锁</p><p>9、非公平锁 无优先级的锁</p><p>10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p><p>11、对象锁 锁住对象</p><p>12、线程锁</p><p>13、锁粗化 多锁变成一个，自己处理</p><p>14、轻量级锁 CAS 实现</p><p>15、锁消除 偏向锁就是锁消除的一种</p><p>16、锁膨胀 jvm实现，锁粗化</p><p>17、信号量 使用阻塞锁 实现的一种策略</p><p>18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如-synchronized-和-ReentrantLock等等-。这些已经写好提供的锁为我们开发提供了便利。&quot;&gt;&lt;a href=&quot;#锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现-如
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么操作会使得当前线程停止？</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%EF%BC%9F/</id>
    <published>2020-05-12T12:38:45.000Z</published>
    <updated>2020-05-12T12:44:10.341Z</updated>
    
    <content type="html"><![CDATA[<p>A：一个InterruptedException 异常被捕获 大家都知道的嘛 （一般通过interrupt方法 中断线程） 如果抓到一个线程 都会关进catch里面 然后中断当前操作。</p><p>B：线程执行了wait()方法。  线程使用了wait方法，会强行打断当前操作，（暂停状态，不会中断线程） 进入阻塞（暂停）状态，然后需要notify方法或notifyAll方法才能进入就绪状态。</p><p>C：当前线程创建了一个新的线程。  新创建的线程不会抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。</p><p>D：一个高优先级别的线程就绪。 如C相同，你优先级别再高 也待等我现在弄完才会给你。</p><p>E：线程在MediaTracker上执行了waitforID（）调用。 </p><p>这个类是awt里面的，他的功能是加载图像，直到完成之前，该方法一直等待！这个方法是必须要抛出A选项的InterruptedException 异常的 说明这玩意会让其他线程 wait他完成！  所以会暂停当前线程~~大概是这样吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A：一个InterruptedException 异常被捕获 大家都知道的嘛 （一般通过interrupt方法 中断线程） 如果抓到一个线程 都会关进catch里面 然后中断当前操作。&lt;/p&gt;
&lt;p&gt;B：线程执行了wait()方法。  线程使用了wait方法，会强行打断当前
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java的反射</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E7%9A%84%E5%8F%8D%E5%B0%84/</id>
    <published>2020-05-12T12:24:53.000Z</published>
    <updated>2020-05-12T12:37:21.860Z</updated>
    
    <content type="html"><![CDATA[<p>反射指的是在运行时能够分析类的能力的程序。</p><p>反射机制可以用来：</p><p>1.在运行时分析类的能力–检查类的结构–所用到的就是<strong>java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的域、方法和构造器</strong>。</p><p>2.在运行时查看对象。</p><p>3.实现通用的数组操作代码。</p><p><strong>反射机制的功能：</strong></p><p>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态方法。</p><p><strong>反射机制常见作用：</strong></p><p>动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。</p><p><strong>反射机制性能问题：</strong></p><p>反射会降低效率。</p><p>void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。禁止安全检查，可以提高反射的运行速度。</p><p>可以考虑使用：cglib/javaassist操作。</p><p> Java语言反射提供一种动态链接程序组件的多功能方法。它允许程序创建和控制任何类的对象(根据安全性限制)，无需提前硬编码目标类。这些特性使得反射特别适用于创建以非常普通的方式与对象协作的库。例如，反射经常在持续存储对象为数据库、XML或其它外部格式的框架中使用。Java reflection非常有用，它使类和数据结构能按名称动态检索相关信息，并允许在运行着的程序中操作这些信息。Java的这一特性非常强大，并且是其它一些常用语言，如C、C++、Fortran 或者Pascal等都不具备的。</p><p>   但反射有两个缺点。第一个是性能问题。用于字段和方法接入时反射要远慢于直接代码。性能问题的程度取决于程序中是如何使用反射的。如果它作为程序运行中相对很少涉及的部分，缓慢的性能将不会是一个问题。即使测试中最坏情况下的计时图显示的反射操作只耗用几微秒。仅反射在性能关键的应用的核心逻辑中使用时性能问题才变得至关重要。</p><p>   许多应用中更严重的一个缺点是使用反射会模糊程序内部实际要发生的事情。程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术会带来维护问题。反射代码比相应的直接代码更复杂，正如性能比较的代码实例中看到的一样。解决这些问题的最佳方案是保守地使用反射一-仅在它可以真正增加灵活性的地方一记录其在 目标类中的使用。</p><p>   Reflection是Java程序开发语言的特征之一，它允许运行中的Java程序对自身进行检查，或者说”自审”，并能直接操作程序的内部属性。例如，使用它能获得Java类中各成员的名称并显示出来。</p><p>   Java的这-能力在实际应用中也许用得不是很多，但是在其它的程序设计语言中根本就不存在这一-特性。例如，Pascal. C或者C++中就没有办法在程序中获得函数定义相关的信息。</p><p>   JavaBean是reflection的实际应用之一，它能让一些工具可视化的操作软件组件。这些工具通过reflection动态的载入并取得Java组件(类)的属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射指的是在运行时能够分析类的能力的程序。&lt;/p&gt;
&lt;p&gt;反射机制可以用来：&lt;/p&gt;
&lt;p&gt;1.在运行时分析类的能力–检查类的结构–所用到的就是&lt;strong&gt;java.lang.reflect包中的Field、Method、Constructor，分别用于描述类的域、方法
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中的关键字与保留字</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/</id>
    <published>2020-05-12T12:21:57.000Z</published>
    <updated>2020-05-12T12:24:26.372Z</updated>
    
    <content type="html"><![CDATA[<p>Java关键字是<a href="https://baike.baidu.com/item/电脑语言/7105622" target="_blank" rel="noopener">电脑语言</a>里事先定义的，有特别意义的标识符，有时又叫<a href="https://baike.baidu.com/item/保留字/7674788" target="_blank" rel="noopener">保留字</a>，还有特别意义的变量。Java的关键字对Java的<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名和参数。</p><p> java中true ,false , null在java中不是关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符。</p><p>其中const和goto是java的保留字。java中所有的关键字都是小写的，还有要注意true,false,null,　friendly，sizeof不是java的关键字,但是你不能把它们作为java标识符用。</p><p>goto和const是保留字也是关键字。</p><p>关键字列表 (依字母排序 共50组)：</p><p>abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）, continue, default, do, double, else, enum, extends, final, finally, float, for, goto（保留关键字）, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while</p><p>保留字列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：</p><p>byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto （保留关键字） , const （保留关键字） , null</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java关键字是&lt;a href=&quot;https://baike.baidu.com/item/电脑语言/7105622&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;电脑语言&lt;/a&gt;里事先定义的，有特别意义的标识符，有时又叫&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于ArrayLinst与LinkList</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/</id>
    <published>2020-05-12T11:33:30.000Z</published>
    <updated>2020-05-12T11:42:07.005Z</updated>
    
    <content type="html"><![CDATA[<p>A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数增加，数组无法存储时，系统会另个申请一个长度为当前长度1.5倍的数组，然后，把之前的数据拷贝到新建的数组。</p><p>- ———————————————————————</p><p>B. 对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。ArrayList是数组，所以，直接定位到相应位置取元素，LinkedLIst是链表，所以需要从前往后遍历。</p><p>-———————————————————————-</p><p>C. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。ArrayList的新增和删除就是数组的新增和删除，LinkedList与链表一致。</p><p>-————————————————————————</p><p>D. ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。因为ArrayList空间的增长率为1.5倍，所以，最后很可能留下一部分空间是没有用到的，因此，会造成浪费的情况。对于LInkedList的话，由于每个节点都需要额外的指针，所以，你懂的。</p><p>下面放一张ArrayList和LinkedList的区别表：</p><img src="/2020/05/12/%E5%85%B3%E4%BA%8EArrayLinst%E4%B8%8ELinkList/p1.png" class title="ArrayList和LinkedList的区别表">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 这里的所谓动态数组并不是那个“ 有多少元素就申请多少空间 ”的意思，通过查看源码，可以发现，这个动态数组是这样实现的，如果没指定数组大小，则申请默认大小为10的数组，当元素个数
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于java内存区域</title>
    <link href="http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/05/12/%E5%85%B3%E4%BA%8Ejava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2020-05-12T11:26:47.000Z</published>
    <updated>2020-05-12T11:31:43.382Z</updated>
    
    <content type="html"><![CDATA[<p>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；</p><p>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。 没有类信息，类信息是在方法区中</p><p>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组</p><p>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>二叉树查找的时间复杂度</title>
    <link href="http://yoursite.com/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/05/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2020-05-12T11:22:50.000Z</published>
    <updated>2020-05-12T11:25:39.246Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树查找的时间复杂度"><a href="#二叉树查找的时间复杂度" class="headerlink" title="二叉树查找的时间复杂度"></a>二叉树查找的时间复杂度</h4><p>​        给定值的比较次数等于给定值节点在二叉排序树中的层数。如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2(n+1),其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;二叉树查找的时间复杂度&quot;&gt;&lt;a href=&quot;#二叉树查找的时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;二叉树查找的时间复杂度&quot;&gt;&lt;/a&gt;二叉树查找的时间复杂度&lt;/h4&gt;&lt;p&gt;​        给定值的比较次数等于给定值节点在二叉排序树中的层数
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>堆与栈的概念和区别</title>
    <link href="http://yoursite.com/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-12T07:08:42.000Z</published>
    <updated>2020-05-12T07:19:59.262Z</updated>
    
    <content type="html"><![CDATA[<p>​        Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。</p><p>   JVM内存的划分有五片：</p><p>​    1.  寄存器；</p><p>​    2.  本地方法区；</p><p>​    3.  方法区；</p><p>​    4.  栈内存；</p><p>​    5.  堆内存</p><img src="/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/heapandstack.png" class title="堆与栈"><p> 我们重点来说一下堆和栈：</p><p>​        栈内存:栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p><pre><code>堆内存:存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</code></pre><p>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</p><p><strong>·    栈区:</strong></p><ol><li><p>每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中</p></li><li><p>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</p></li><li><p>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p></li></ol><p><strong>·    堆区:</strong></p><ol><li><p>存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。</p></li><li><p>jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。</p></li></ol><p><strong>·    方法区:</strong></p><ol><li><p>又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><img src="/2020/05/12/%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/p2.png" class title="java内存区域"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        Java程序在运行时都要开辟空间，任何软件在运行时都要在内存中开辟空间，Java虚拟机运行时也是要开辟空间的。JVM运行时在内存中开辟一片内存区域，启动时在自己的内存区域中进行更细致的划分，因为虚拟机中每一片内存处理的方式都不同，所以要单独进行管理。&lt;/p
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池的作用</title>
    <link href="http://yoursite.com/2020/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-05-12T07:01:06.000Z</published>
    <updated>2020-05-12T07:07:52.960Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据库连接池的作用"><a href="#数据库连接池的作用" class="headerlink" title="数据库连接池的作用"></a>数据库连接池的作用</h4><p>​        对于一个简单的数据库引用，用于对数据库的访问不是很频繁。这时就可以简单的在需要访问数据库是，就创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库引用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。</p><p>　　对于共享资源，有一个很著名的设计模式：资源池。该模式正是为了解决资源频繁分配、释放所造成的问题的。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略，最终目标是实现连接的高效、安全的复用。 </p><p>　　数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。如：外部使用者可通过getConnection 方法获取连接，使用完毕后再通过releaseConnection 方法将连接返回，注意此时连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备。</p><p>数据库连接池技术带来的优势：</p><p><strong>1.限定了数据库连接的个数，不会由于数据库连接过多，导致系统运行缓慢或者崩溃</strong></p><p><strong>2.不需要每次去创建或销毁，节约资源</strong></p><p><strong>3.不需要每次都去创建，相应时间更快</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据库连接池的作用&quot;&gt;&lt;a href=&quot;#数据库连接池的作用&quot; class=&quot;headerlink&quot; title=&quot;数据库连接池的作用&quot;&gt;&lt;/a&gt;数据库连接池的作用&lt;/h4&gt;&lt;p&gt;​        对于一个简单的数据库引用，用于对数据库的访问不是很频繁。这时就可以
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>创建多线程的4种方式</title>
    <link href="http://yoursite.com/2020/05/11/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/05/11/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2020-05-11T12:38:14.000Z</published>
    <updated>2020-05-11T14:13:30.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="java中创建多线程的4种方式"><a href="#java中创建多线程的4种方式" class="headerlink" title="java中创建多线程的4种方式"></a>java中创建多线程的4种方式</h4><h5 id="1-线程是什么？"><a href="#1-线程是什么？" class="headerlink" title="1.线程是什么？"></a>1.线程是什么？</h5><p>​    线程被称为轻量级进程，是程序执行的最小单位，它是指在程序执行过程中，能够执行代码的一个执行单位。每个程序都至少有一个线程，也即是程序本身。</p><h5 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2.线程状态"></a>2.线程状态</h5><p>​    Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中一个状态。，这5种状态如下：</p><p>（1）新建（New）：创建后尚未启动的线程处于这种状态</p><p>（2）运行（Runable）：Runable包括了操作系统线程状态的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</p><p>（3）等待（Wating）：处于这种状态的线程不会被分配CPU执行时间。等待状态又分为无限期等待和有限期等待，处于无限期等待的线程需要被其他线程显示地唤醒，没有设置Timeout参数的Object.wait()、没有设置Timeout参数的Thread.join()方法都会使线程进入无限期等待状态；有限期等待状态无须等待被其他线程显示地唤醒，在一定时间之后它们会由系统自动唤醒，Thread.sleep()、设置了Timeout参数的Object.wait()、设置了Timeout参数的Thread.join()方法都会使线程进入有限期等待状态。</p><p>（4）阻塞（Blocked）：线程被阻塞了，“阻塞状态”与”等待状态“的区别是：”阻塞状态“在等待着获取到一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而”等待状态“则是在等待一段时间或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p><p>（5）结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p><h5 id="3-java创建多线程的四种方式"><a href="#3-java创建多线程的四种方式" class="headerlink" title="3.java创建多线程的四种方式"></a>3.java创建多线程的四种方式</h5><p>（1）   继承Thread类创建线程</p><p>（2）   实现Runnable接口创建线程</p><p>（3）   使用Callable和FutureTask创建线程</p><p>（4）   使用线程池，例如用Executor框架创建线程</p><p><strong>1)继承Thread类创建线程步骤如下：</strong></p><p>定义一个继承Thread线程类的类，在类中重写run方法。</p><p>在main函数中实例化这个类，初始化实现继承Thread类的对象。</p><p>用这个类的实例调用start方法，执行覆写的run方法。这里是父类即Thread接收创建的对象，由于自身没有start方法，所以是调用父类Thread的start方法创建线程。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//继承Thread类</span></span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">new</span> MyThread().start();<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2)实现Runnable接口创建线程步骤如下：</strong></p><p>定义一个实现Runnable接口的类A，在类中重写run方法。</p><p>在main函数中实例化这个类，但是注意，这不是线程类或者其子类，无法使用start方法，所以无法像1)方法一样用父类接收其对象直接调用start方法执行run方法。</p><p>实例化线程类，将上一步实例化的Runnable接口的类作为参数传给Thread线程类，初始化线程对象，即 Thread t = new Thread(new A());</p><p>线程类实例调用start方法执行run方法体。</p><p>为什么不直接调用run方法，而是必须先调用start方法呢？</p><p>因为start方法会启动线程，此时该线程处于就绪状态，start方法体中有一个start0的native方法，在这个方法里创建了线程，并且执行调用了重写的run方法，在run方法结束时，线程便会中止，也就是start0方法退出时。如果是直接调用run方法，即调用重写的run方法，这和普通方法没有什么区别，不会创建新线程，因为创建新线程，使线程处于就绪状态的操作在start方法中，而run方法会被jvm在start方法中的start0中调用。</p><p> 代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">//重写run方法</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　　　MyThread2 myThread=<span class="keyword">new</span> MyThread2();</span><br><span class="line"></span><br><span class="line">　　　　Thread thread=<span class="keyword">new</span> Thread(myThread);</span><br><span class="line"></span><br><span class="line">　　　　thread().start();</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">//或者    new Thread(new MyThread2()).start();</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start0方法源码解析请看<a href="https://www.jianshu.com/p/81a56497e073" target="_blank" rel="noopener">https://www.jianshu.com/p/81a56497e073</a></p><p>一个线程可以多次调用start方法吗?</p><p>不能，会抛出下列异常，也就是非法线程状态异常，属于运行异常。查看源码可以看到在执行start时，会对线程状态进行判断，如果线程已经启动过，那么通常情况下无法再次进行启动，这一点在源码注释中也可以看到。即在同一个线程只能start一次，多次调用start方法会抛出异常。当调用start方法时，线程会被添加到线程组中，等待线程调度器调用，当获取到资源时，就进入运行状态。</p><p>源码分析请看<a href="https://cloud.tencent.com/developer/article/1386458" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1386458</a></p><p><strong>3)使用Callable和FutureTask创建线程步骤如下：</strong></p><p>和Runnable接口不一样，Callable接口提供了一个call（）方法作为线程执行体，call()方法比run()方法功能要强大。</p><blockquote><p><strong>call()方法可以有返回值</strong></p></blockquote><blockquote><p><strong>call()方法可以声明抛出异常</strong></p></blockquote><p>Java5之后提供了Future接口来代表Callable接口里call()方法的返回值，并且为Future接口提供了一个实现类FutureTask，这个实现类既实现了Future接口，还实现了Runnable接口，因此可以作为Thread类的target。在Future接口里定义了几个公共方法来控制它关联的Callable任务。</p><blockquote><p>boolean cancel(boolean mayInterruptIfRunning)：视图取消该Future里面关联的Callable任务</p></blockquote><blockquote><p>V get()：返回Callable里call（）方法的返回值，调用这个方法会导致程序阻塞，必须等到子线程结束后才会得到返回值</p></blockquote><blockquote><p>V get(long timeout,TimeUnit unit)：返回Callable里call（）方法的返回值，最多阻塞timeout时间，经过指定时间没有返回抛出TimeoutException</p></blockquote><blockquote><p>boolean isDone()：若Callable任务完成，返回True</p></blockquote><blockquote><p>boolean isCancelled()：如果在Callable任务正常完成前被取消，返回True</p></blockquote><p>介绍了相关的概念之后，创建并启动有返回值的线程的步骤如下：</p><p><font color="#006666"> 1】创建Callable接口的实现类，并实现call()方法，然后创建该实现类的实例（从java8开始可以直接使用Lambda表达式创建Callable对象）。</font><br></p><p><font color="#006666">2】使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</font><br></p><p><font color="#006666">3】使用FutureTask对象作为Thread对象的target创建并启动线程（因为FutureTask实现了Runnable接口）</font><br></p><p><font color="#006666">4】调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</font><br></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">　　　MyThread3 th=<span class="keyword">new</span> MyThread3();</span><br><span class="line"></span><br><span class="line">　　　<span class="comment">//使用Lambda表达式创建Callable对象</span></span><br><span class="line"></span><br><span class="line">　　   <span class="comment">//使用FutureTask类来包装Callable对象</span></span><br><span class="line"></span><br><span class="line">　　　FutureTask&lt;Integer&gt; future=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line"></span><br><span class="line">　　　　(Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　  );</span><br><span class="line"></span><br><span class="line">　　　<span class="keyword">new</span> Thread(task,<span class="string">"有返回值的线程"</span>).start();<span class="comment">//实质上还是以Callable对象来创建并启动线程</span></span><br><span class="line"></span><br><span class="line">　　  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　System.out.println(<span class="string">"子线程的返回值："</span>+future.get());<span class="comment">//get()方法会阻塞，直到子线程执行结束才返回</span></span><br><span class="line"></span><br><span class="line"> 　　 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">　　　　ex.printStackTrace();</span><br><span class="line"></span><br><span class="line">　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前三种方式比较：</strong></p><p>实现Runnable和实现Callable接口的方式基本相同，不过是后者执行call()方法有返回值，后者线程执行体run()方法无返回值，因此可以把这两种方式归为一种这种方式与继承Thread类的方法之间的差别如下：</p><p>1、线程只是实现Runnable或实现Callable接口，还可以继承其他类。</p><p>2、这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。</p><p>3、但是编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。</p><p>4、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。</p><p>注：一般推荐采用实现接口的方式来创建多线程</p><p><strong>4)使用线程池，例如用Executor框架步骤如下：</strong></p><p>使用Executors工具类中的静态工厂方法用于创建线程池。</p><p>创建线程池使用execute方法启动线程。</p><p>使用shutdown方法等待提交的任务执行完成并后关闭线程。</p><p>Runnable和Callable有什么区别？</p><p>Runnable接口定义的run方法，Callable定义的是call方法。</p><p>run方法没有返回值，call方法必须有返回值。</p><p>run方法无法抛出异常，call方法可以抛出checked exception。</p><p>Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.</p><p>几种方法优缺点对比：<a href="https://blog.csdn.net/sinat_27933301/article/details/69944286" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27933301/article/details/69944286</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;java中创建多线程的4种方式&quot;&gt;&lt;a href=&quot;#java中创建多线程的4种方式&quot; class=&quot;headerlink&quot; title=&quot;java中创建多线程的4种方式&quot;&gt;&lt;/a&gt;java中创建多线程的4种方式&lt;/h4&gt;&lt;h5 id=&quot;1-线程是什么？&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中输入url会发生的过程</title>
    <link href="http://yoursite.com/2020/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2020-05-11T07:14:54.000Z</published>
    <updated>2020-05-11T12:08:49.382Z</updated>
    
    <content type="html"><![CDATA[<p>游览器输入地址之后与服务器交互的具体步骤</p><ol><li><p>DNS域名解析</p></li><li><p>建立TCP连接</p></li><li><p>发送HTTP请求</p></li><li><p>服务器处理请求</p></li><li><p>返回结果响应</p></li><li><p>关闭TCP连接</p></li><li><p>游览器解析HTML</p></li><li><p>布局渲染</p><p><a href="https://blog.csdn.net/ZWE7616175/article/details/80484905" target="_blank" rel="noopener">详细介绍地址</a></p></li></ol><h5 id="Tcp的三次握手协议"><a href="#Tcp的三次握手协议" class="headerlink" title="Tcp的三次握手协议"></a>Tcp的三次握手协议</h5><p><img src="/2020/05/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E4%BC%9A%E5%8F%91%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B/tcp3.png" alt="没有找到这张图片"></p><p><strong>第一次握手：</strong>建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p><strong>第三次握手：</strong>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><h5 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a><strong>常见面试题</strong></h5><p><strong>【问题1】</strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p><strong>【问题2】</strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p><strong>【问题3】</strong>为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>​    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p><strong>【问题4】</strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;游览器输入地址之后与服务器交互的具体步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;DNS域名解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立TCP连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发送HTTP请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器处理请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么是事务？</title>
    <link href="http://yoursite.com/2020/05/11/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/11/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F/</id>
    <published>2020-05-11T07:07:00.000Z</published>
    <updated>2020-05-11T07:13:46.244Z</updated>
    
    <content type="html"><![CDATA[<p><strong>事务：</strong>是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</p><p><strong>事务的四大特性：</strong></p><h6 id="1-、原子性"><a href="#1-、原子性" class="headerlink" title="1 、原子性"></a>1 、原子性</h6><p>事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</p><h6 id="2-、一致性"><a href="#2-、一致性" class="headerlink" title="2 、一致性"></a>2 、一致性</h6><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 </p><h6 id="3-、隔离性"><a href="#3-、隔离性" class="headerlink" title="3 、隔离性"></a>3 、隔离性</h6><p>一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><h6 id="4-、持续性"><a href="#4-、持续性" class="headerlink" title="4 、持续性"></a>4 、持续性</h6><p>也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p><p>原子性是基础，隔离性是手段，一致性是约束条件，而持久性是目的。</p><p>简称ACID</p><p>原子性（Atomicity），一致性（Consistency）,隔离性（Isolation）和持久性（Durability）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;事务：&lt;/strong&gt;是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事务的四大特性：&lt;/st
      
    
    </summary>
    
    
      <category term="牛客小知识" scheme="http://yoursite.com/categories/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="http://yoursite.com/2020/05/08/%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/05/08/%E6%B5%8B%E8%AF%95/</id>
    <published>2020-05-08T11:24:38.000Z</published>
    <updated>2020-05-11T02:58:43.033Z</updated>
    
    <content type="html"><![CDATA[<p>没有什么，测试而已</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没有什么，测试而已&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>利用Eureka注册中心动态获取服务</title>
    <link href="http://yoursite.com/2019/12/21/%E5%88%A9%E7%94%A8Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/12/21/%E5%88%A9%E7%94%A8Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1/</id>
    <published>2019-12-21T13:05:33.000Z</published>
    <updated>2020-05-11T02:57:13.410Z</updated>
    
    <content type="html"><![CDATA[<p>​        在上一节的微服务场景模拟中，存在以下问题：</p><ul><li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li><li>consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效</li><li>consumer不清楚user-service的状态，服务宕机也不知道</li><li>user-service只有1台服务，不具备高可用性</li><li>即便user-service形成集群，consumer还需自己实现负载均衡</li></ul><p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><a id="more"></a><h3 id="一、Eureka注册中心"><a href="#一、Eureka注册中心" class="headerlink" title="一、Eureka注册中心"></a>一、Eureka注册中心</h3><h4 id="1-1-了解Eureka"><a href="#1-1-了解Eureka" class="headerlink" title="1.1 了解Eureka"></a>1.1 了解Eureka</h4><p>​        Eureka就像是一个中介，负责管理、记录服务提供者的信息，服务提供者在这个中心上注册自己所提供的服务，Eureka负责检测这个服务提供者是否在持续的提供服务，如果检测到服务终止，那么就会在注册中心进行注销，服务调用者也就不会使用到没法提供服务的服务商；同时，服务调用者也需在中心进行注册，把自己的需求告诉Eureka，然后Eureka会把负荷你需求的服务告诉你。</p><p>​        Eureka实现了服务的自动注册、发现、状态监控。</p><h4 id="1-2-编写EurekaServer"><a href="#1-2-编写EurekaServer" class="headerlink" title="1.2 编写EurekaServer"></a>1.2 编写EurekaServer</h4><p>​        创建module，以cloud-demo为父工程，添加依赖。</p><ul><li>子工程Eureka-server的pom.xml配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.nedlee.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Eureka服务端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.nedlee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//注解提供Eureka服务</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>application.yml配置文件</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="二、将user-service注册到Eureka"><a href="#二、将user-service注册到Eureka" class="headerlink" title="二、将user-service注册到Eureka"></a>二、将user-service注册到Eureka</h3><p>​        注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。</p><ul><li>在user-service子工程的pom.xml中添加springcloud依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.nedlee.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在启动类上开启Eureka客户端功能</p></blockquote><p>通过添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启EurekaClient功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(UserServiceDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>application.yml文件配置</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 应用名称</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/leyou</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">873383</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.nedlee.user.pojo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">      <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br></pre></td></tr></table></figure><h3 id="三、消费者从Eureka获取服务"><a href="#三、消费者从Eureka获取服务" class="headerlink" title="三、消费者从Eureka获取服务"></a>三、消费者从Eureka获取服务</h3><p>​        方法与服务提供者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p><ul><li>在子工程consumer-demo的pom.xml中添加springcloud依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.nedlee.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在启动类开启Eureka客户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启Eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConsumerDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(<span class="keyword">new</span> OkHttp3ClientHttpRequestFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserConsumerDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改application.yml配置文件</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><ul><li>修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.nedlee.consumer.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.nedlee.consumer.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.DiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="comment">//根据服务id获取实例</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"user-service"</span>);</span><br><span class="line">        <span class="comment">//从实例中取出ip和端口</span></span><br><span class="line">        <span class="comment">// 因为只有一个User-Service,因此我们直接get(0)获取</span></span><br><span class="line">        ServiceInstance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">        String url = <span class="string">"http://"</span>+instance.getHost() + <span class="string">":"</span> +instance.getPort()+<span class="string">"/user/"</span> + id;</span><br><span class="line">        User user = restTemplate.getForObject(url,User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        至此，Eureka注册中心的功能以基本实现，需要注意的是Eureka注册中心也需要将自己注册到该中心，以@EurekaServer的方式开启服务，在中心的服务提供者与调用者都是以@EurekaDiscoveryClient的方式开启客户端，也可以使用@EurekaClient，但是前者更加通用，因为服务中心不止Eureka这一家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        在上一节的微服务场景模拟中，存在以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在consumer中，我们把url地址硬编码到了代码中，不方便后期维护&lt;/li&gt;
&lt;li&gt;consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效&lt;/li&gt;
&lt;li&gt;consumer不清楚user-service的状态，服务宕机也不知道&lt;/li&gt;
&lt;li&gt;user-service只有1台服务，不具备高可用性&lt;/li&gt;
&lt;li&gt;即便user-service形成集群，consumer还需自己实现负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实上面说的问题，概括一下就是分布式服务必然要面临的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务管理&lt;ul&gt;
&lt;li&gt;如何自动注册和发现&lt;/li&gt;
&lt;li&gt;如何实现状态监管&lt;/li&gt;
&lt;li&gt;如何实现动态路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务如何实现负载均衡&lt;/li&gt;
&lt;li&gt;服务如何解决容灾问题&lt;/li&gt;
&lt;li&gt;服务如何实现统一配置&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="框架学习、springboot与springcloud" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E3%80%81springboot%E4%B8%8Espringcloud/"/>
    
    
      <category term="springcloud" scheme="http://yoursite.com/tags/springcloud/"/>
    
  </entry>
  
</feed>
